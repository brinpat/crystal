# -*- coding: utf-8 -*-
"""Crystallised.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fP3EGAzCYNrukS3zgJUny1r7oq_-tJW7

# Imports
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import norm, multivariate_normal
import pandas as pd
from mpl_toolkits import mplot3d
from mpl_toolkits.mplot3d import Axes3D
import pandas as pd

"""## Install pyvista"""

pip install pyvista

import pyvista as pv

# setup enviornment for interactive plotting
!apt-get install -qq xvfb
!pip install pyvista panel -q

import os
os.system('/usr/bin/Xvfb :99 -screen 0 1024x768x24 &')
os.environ['DISPLAY'] = ':99'

import panel as pn
pn.extension('vtk')

# ### new cell spline example cell ###
# pn.extension('vtk')  # this needs to be at the top of each cell for some reason

"""# Quantum Distribution Physics

## Modelling electron waves with normal distributions
"""

# params
f = 2 # also number of electrons
lam = 0.73 # also atomic radius
L = f*lam

x = np.arange(-0.5*L,0.5*L,0.001)

phi = np.sqrt(2/L)*np.sin(2*np.pi*f*x/L)
plt.plot(x,phi)
wf = 2/L*abs(phi)**2
wf_prob = sum(wf)
wf_prob

def mergedist(lamb, frequency, n):
  L = frequency*lamb
  datarange = np.arange(-0.5*L,0.5*L,0.001)
  d = norm.pdf(datarange, lamb/n, (lamb/np.pi)**2)/n
  df = pd.DataFrame(d, columns = np.arange(0,1))

  for i in range(0,n):
    d2 = norm.pdf(datarange, lamb*(2*i-n+1)/4, lamb/20)/n 
    # d2 = norm.pdf(datarange, (2*i-n+1)*lamb/n, lamb/(frequency*(n+1)))/n 
    df[i] = d2.tolist()

  return df, datarange

nnn,xdata = mergedist(lam, f, 2*f)
nnn['sum'] = nnn. sum(axis=1)
#plt.plot(x,nnn['sum'])

plt.plot(x,nnn)

plt.plot(x,nnn['sum']/L)

plt.plot(x,wf)

"""## Electron configuration in atoms"""

def electrodist(f,r1):
  distdata = 2*f*np.sum(mergedist(r1, f, 2*f)[0],axis=1) # increased the probability value while reduced the range in order to get total probability for all orbitals
  xdata = mergedist(r1, f, 2*f)[1]
  return distdata, xdata

"""### H2O"""

# Water (H2O)
h_atomic_radius = 0.37 # angstrom
o_atomic_radius = 0.73 # angstrom

# Hydrogen
f=1
dist1 = 2*f*np.sum(mergedist(h_atomic_radius, f, 2*f)[0],axis=1) # increased the probability value while reduced the range in order to get total probability for all orbitals
x1 = mergedist(h_atomic_radius, f, 2*f)[1]
x1 = (2*x1*h_atomic_radius/max(x1) - o_atomic_radius - 3*h_atomic_radius)/2

# Oxygen shell 1

f=2
dist2 = 2*f*np.sum(mergedist(o_atomic_radius, f, 2*f)[0],axis=1)
x2 = mergedist(o_atomic_radius, f, 2*f)[1]
x2 = (x2 - 0.5*o_atomic_radius)/2

# Oxygen shell 2
f=6
dist3 = 2*f*np.sum(mergedist(o_atomic_radius, f, 2*f)[0],axis=1)
x3 = mergedist(o_atomic_radius, f, 2*f)[1]
x3 = (x3 - o_atomic_radius)/2

# plots
plt.plot(x1[x1>=-2.5*h_atomic_radius] , dist1[x1>=-2.5*h_atomic_radius]/max(dist1))
plt.plot(-x3[x3>=o_atomic_radius/4], dist3[x3>=o_atomic_radius/4]/max(dist1))
plt.plot(-x2[x2>=0], 2*dist2[x2>=0]/max(dist1))
plt.plot(x2[x2>=0], 2*dist2[x2>=0]/max(dist1))
plt.plot(x3[x3>=o_atomic_radius/4], dist3[x3>=o_atomic_radius/4]/max(dist1))
plt.plot(-x1[x1>=-2.5*h_atomic_radius] , dist1[x1>=-2.5*h_atomic_radius]/max(dist1))

plt.xlim(-1,1)

# Water (H2O)
h_atomic_radius = 0.37 # angstrom
o_atomic_radius = 0.73 # angstrom

# Hydrogen
dist1, x1 = electrodist(1,h_atomic_radius)
x1 = (2*x1*h_atomic_radius/max(x1) - o_atomic_radius - 3*h_atomic_radius)/2

# Oxygen shell 1
dist2, x2 = electrodist(2,o_atomic_radius)
x2 = (x2 - 0.5*o_atomic_radius)/2

# Oxygen shell 2
dist3, x3 = electrodist(6,o_atomic_radius)
x3 = (x3 - o_atomic_radius)/2

# plots
plt.plot(x1[x1>=-2.5*h_atomic_radius] , dist1[x1>=-2.5*h_atomic_radius]/max(dist1))
plt.plot(-x3[x3>=o_atomic_radius/4], dist3[x3>=o_atomic_radius/4]/max(dist1))
plt.plot(-x2[x2>=0], 2*dist2[x2>=0]/max(dist1))
plt.plot(x2[x2>=0], 2*dist2[x2>=0]/max(dist1))
plt.plot(x3[x3>=o_atomic_radius/4], dist3[x3>=o_atomic_radius/4]/max(dist1))
plt.plot(-x1[x1>=-2.5*h_atomic_radius] , dist1[x1>=-2.5*h_atomic_radius]/max(dist1))

plt.xlim(-1,1)

"""### Generalised"""

def electrodist(f,r1):
  distdata = 2*f*np.sum(mergedist(r1, f, 2*f)[0],axis=1) # increased the probability value while reduced the range in order to get total probability for all orbitals
  xdata = mergedist(r1, f, 2*f)[1]
  return distdata, xdata

"""### H2O"""

# Atom radii
atom1 = 0.37 # angstrom
atom2 = 0.73 # angstrom

## Atom 1

# Shell 1
dist1_1, x1_1 = electrodist(1,atom1) #1:2
x1_1 = (2*x1_1*atom1/max(x1_1) - atom2 - 3*atom1)/2

# Shell 2
dist2_1, x2_1 = electrodist(3,atom2) #3
x2_1 = (2*x2_1*atom1/max(x2_1) - atom2 - 3*atom1)/2


## Atom 2 (central)

# Shell 1
dist1_2, x1_2 = electrodist(2,atom2) #2
x1_2 = (x1_2 - atom2)/2

# Shell 2
dist3_2, x3_2 = electrodist(6,atom2) #6
x3_2 = (x3_2 - atom2)/2

# plots

# Atom 1
#plt.plot(x2_1[x2_1>=-2.5*atom1] , dist2_1[x2_1>=-5/2*atom1])
plt.plot(x1_1[x1_1>=-2.5*atom1] , dist1_1[x1_1>=-5/2*atom1])

# Atom 2
plt.plot(-x3_2[x3_2>=atom2/4], dist3_2[x3_2>=atom2/4])
plt.plot(-x1_2[x1_2>=-atom2/4], 2*dist1_2[x1_2>=-atom2/4])
plt.plot(x1_2[x1_2>=-atom2/4], 2*dist1_2[x1_2>=-atom2/4])
plt.plot(x3_2[x3_2>=atom2/4], dist3_2[x3_2>=atom2/4])

# Atom 1
plt.plot(-x1_1[x1_1>=-2.5*atom1] , dist1_1[x1_1>=-5/2*atom1])
#plt.plot(-x2_1[x2_1>=-2.5*atom1] , dist2_1[x2_1>=-5/2*atom1])

plt.xlim(-1.5,1.5)

"""### CO2"""

# Atom radii
atom1 = 0.73 # angstrom
atom2 = 1.5 # angstrom

## Atom 1
s1_1 = 2
s2_1 = 6

# Shell 1
dist1_1, x1_1 = electrodist(s1_1,atom1) #1:2
x1_1 = (2*x1_1*atom1/max(x1_1) - atom2 - 3*atom1)/2

# Shell 2
dist2_1, x2_1 = electrodist(s2_1,atom2) #3
x2_1 = (2*x2_1*atom1/max(x2_1) - atom2 - 3*atom1)/2


## Atom 2 (central)
s1_2 = 2
s2_2 = 4

# Shell 1
dist1_2, x1_2 = electrodist(s1_2,atom2) #2
x1_2 = atom2*(x1_2 - atom2)/2

# Shell 2
dist3_2, x3_2 = electrodist(s2_2,atom2) #6
x3_2 = atom2*(x3_2 - ((2*s2_2-4)/8)*atom2)/2 # 4:0.5 6:1 8:1.5

# plots

# Atom 1
plt.plot(x2_1[x2_1-2/s2_1>=-5/2*atom1]-0.5*atom1 , dist2_1[x2_1-2/s2_1>=-5/2*atom1])
plt.plot(x1_1[x1_1>=-5/2*atom1]-atom1 , dist1_1[x1_1>=-5/2*atom1])
plt.plot(x2_1[x2_1-2/s2_1>=-5/2*atom1]-2*atom1 , dist2_1[x2_1-2/s2_1>=-5/2*atom1])

# Atom 2
plt.plot(-x3_2[x3_2>=atom2/3], dist3_2[x3_2>=atom2/3])
plt.plot(-x1_2[x1_2>=-atom2/3], 2*dist1_2[x1_2>=-atom2/3])
plt.plot(x1_2[x1_2>=-atom2/3], 2*dist1_2[x1_2>=-atom2/3])
plt.plot(x3_2[x3_2>=atom2/3], dist3_2[x3_2>=atom2/3])

# Atom 1
plt.plot(-x2_1[x2_1-2/s2_1>=-5/2*atom1]+0.5*atom1 , dist2_1[x2_1-2/s2_1>=-5/2*atom1])
plt.plot(-x1_1[x1_1>=-5/2*atom1]+atom1 , dist1_1[x1_1>=-5/2*atom1])
plt.plot(-x2_1[x2_1-2/s2_1>=-5/2*atom1]+2*atom1 , dist2_1[x2_1-2/s2_1>=-5/2*atom1])

plt.xlim(-3,3)

"""### Adaptable"""

# Atom radii
atom1 = 0.37 # angstrom
atom2 = 0.73 # angstrom

## Atom 1
s1_1 = 1
s2_1 = 0

# Shell 1
dist1_1, x1_1 = electrodist(s1_1,atom1) #1:2
x1_1 = (2*x1_1*atom1/max(x1_1) - atom2 - 3*atom1)/2

# Shell 2
if s2_1 > 0:
  dist2_1, x2_1 = electrodist(s2_1,atom2) #3
  x2_1 = (2*x2_1*atom1/max(x2_1) - atom2 - 3*atom1)/2


## Atom 2 (central)
s1_2 = 2
s2_2 = 6

# Shell 1
dist1_2, x1_2 = electrodist(s1_2,atom2) #2
x1_2 = atom2*(x1_2 - atom2)/2

# Shell 2
dist3_2, x3_2 = electrodist(s2_2,atom2) #6
x3_2 = atom2*(x3_2 - ((2*s2_2-4)/8)*atom2)/2 # 4:0.5 6:1 8:1.5

# plots

# Atom 1
if s2_1 > 0:
  plt.plot(x2_1[x2_1-2/s2_1>=-5/2*atom1]-0.5*atom1 , dist2_1[x2_1-2/s2_1>=-5/2*atom1])
  plt.plot(x1_1[x1_1>=-5/2*atom1]-atom1 , dist1_1[x1_1>=-5/2*atom1])
  plt.plot(x2_1[x2_1-2/s2_1>=-5/2*atom1]-2*atom1 , dist2_1[x2_1-2/s2_1>=-5/2*atom1])
if s2_1 == 0:
  plt.plot(x1_1[x1_1>=-5/2*atom1] , dist1_1[x1_1>=-5/2*atom1])

# Atom 2
plt.plot(-x3_2[x3_2>=atom2/5], dist3_2[x3_2>=atom2/5])
plt.plot(-x1_2[x1_2>=-atom2/5], 2*dist1_2[x1_2>=-atom2/5])
plt.plot(x1_2[x1_2>=-atom2/5], 2*dist1_2[x1_2>=-atom2/5])
plt.plot(x3_2[x3_2>=atom2/5], dist3_2[x3_2>=atom2/5])

# Atom 1
if s2_1 > 0:
  plt.plot(-x2_1[x2_1-2/s2_1>=-5/2*atom1]+0.5*atom1 , dist2_1[x2_1-2/s2_1>=-5/2*atom1])
  plt.plot(-x1_1[x1_1>=-5/2*atom1]+atom1 , dist1_1[x1_1>=-5/2*atom1])
  plt.plot(-x2_1[x2_1-2/s2_1>=-5/2*atom1]+2*atom1 , dist2_1[x2_1-2/s2_1>=-5/2*atom1])
if s2_1 == 0:
  plt.plot(-x1_1[x1_1>=-5/2*atom1] , dist1_1[x1_1>=-5/2*atom1])

plt.xlim(-2,2)

"""### Atomic surface"""

# Atom radii
atom1 = 0.37 # angstrom
atom2 = 0.73 # angstrom

## Atom 1
s1_1 = 1
s2_1 = 0

# Shell 1
dist1_1, x1_1 = electrodist(s1_1,atom1) #1:2
x1_1 = (2*x1_1*atom1/max(x1_1) - atom2 - 3*atom1)/2

# Shell 2
if s2_1 > 0:
  dist2_1, x2_1 = electrodist(s2_1,atom2) #3
  x2_1 = (2*x2_1*atom1/max(x2_1) - atom2 - 3*atom1)/2


## Atom 2 (central)
s1_2 = 2
s2_2 = 6

# Shell 1
dist1_2, x1_2 = electrodist(s1_2,atom2) #2
x1_2 = atom2*(x1_2 - atom2)/2

# Shell 2
dist3_2, x3_2 = electrodist(s2_2,atom2) #6
x3_2 = atom2*(x3_2 - ((2*s2_2-4)/8)*atom2)/2 # 4:0.5 6:1 8:1.5

def molecule(translate):
  # Atom 1
  if s2_1 > 0:
    plt.plot(x2_1[x2_1-2/s2_1>=-5/2*atom1]-0.5*atom1+translate , dist2_1[x2_1-2/s2_1>=-5/2*atom1])
    plt.plot(x1_1[x1_1>=-5/2*atom1]-atom1+translate , dist1_1[x1_1>=-5/2*atom1])
    plt.plot(x2_1[x2_1-2/s2_1>=-5/2*atom1]-2*atom1+translate , dist2_1[x2_1-2/s2_1>=-5/2*atom1])
  if s2_1 == 0:
    plt.plot(x1_1[x1_1>=-5/2*atom1]+translate , dist1_1[x1_1>=-5/2*atom1])

  # Atom 2
  plt.plot(-x3_2[x3_2>=atom2/5]+translate, dist3_2[x3_2>=atom2/5])
  plt.plot(-x1_2[x1_2>=-atom2/5]+translate, 2*dist1_2[x1_2>=-atom2/5])
  plt.plot(x1_2[x1_2>=-atom2/(s2_2-1)]+translate, 2*dist1_2[x1_2>=-atom2/(s2_2-1)])
  plt.plot(x3_2[x3_2>=atom2/(s2_2-1)]+translate, dist3_2[x3_2>=atom2/(s2_2-1)])

  # Atom 1
  if s2_1 > 0:
    plt.plot(-x2_1[x2_1-2/s2_1>=-5/2*atom1]+0.5*atom1+translate , dist2_1[x2_1-2/s2_1>=-5/2*atom1])
    plt.plot(-x1_1[x1_1>=-5/2*atom1]+atom1+translate , dist1_1[x1_1>=-5/2*atom1])
    plt.plot(-x2_1[x2_1-2/s2_1>=-5/2*atom1]+2*atom1+translate , dist2_1[x2_1-2/s2_1>=-5/2*atom1])
  if s2_1 == 0:
    plt.plot(-x1_1[x1_1>=-5/2*atom1]+translate , dist1_1[x1_1>=-5/2*atom1])

# plots

## Molecules

tr = 2*(atom1 + atom2)
rng = 5

#tr = 40
#rng = 120
#rng = 10**4 # micrometre 
# metre of surface is 10**10

for i in range(-round(rng/tr),round(rng/tr)):
  molecule(i*tr)

plt.xlim(-rng,rng)

"""# Quantum Relativity

## Categorising planets
"""

def orbital_free_ratio(gravity):
  return gravity*(9.1E-31)*(6.63E-34)/(1.6E-19)**2

def total_electrons(mass):
  return 0.49*mass/(1.672619*10**-27) # total number of electrons

# Planetary data

planet = np.array(['Merc 3.7', 'Venus 8.8', 'Earth 9.8', 'Mars 3.7', 'Jupiter 24.7', 'Saturn 10.5', 'Uranus 9.0','Neptune 11.7','Pluto 0.49', 'Sun 293.0'])

Volume = np.array([6.08*10**19,9.2843*10**20,1.0832*10**21,1.6318*10**20,1.43128*10**24,8.2713*10**23,6.833*10**22,6.254E22,6.4E18,1.4*10**27])
Pressure = np.array([101325,93*101325,101325,610,400000,140000,101325,1000E5,0.022,340000000000*101325])  # pascals
Temp = np.array([415,737,288,210,165,134,76,72,44,5778])  # kelvin
Core_Pressure = np.array([5,700,330,40,3000,4620,800,10,1.34,2.6E7])  # gigapascals (Venus unknown)
Sun_distance = np.array([0.39,0.72,1,1.52,5.2,9.54,19.2,30.06,39,0.001]) # au

relperm = np.array([5000,8000,8000,8000,1,1,1,8000,1,1])  # air = 1, pure iron - 8000
B = np.array([0,0,38,0.1,550,400,32,27,0,76])*10**-6  # sufarce B_r
t = np.array([1408,5832,24,25,10,11,17,16,6.4*24,34*24])*60*60  # seconds in planet day

Tcore = np.array([8000,5160,5000,1500,20000,35000,5000,7273,1000,15E6])  # kelvin

Grav = np.array([3.7,8.8,9.8,3.7,24.7,10.5,9.0,11.7,0.49,293.0])  # m2s_2
mass = np.array([0.330,4.87,5.97,0.642,1898,568,86.8,1.024E2,0.01303,1989000])*10**24  # kg

## Include Moons ##

moon = np.array(['Moon 1.6', 'Titan (Saturn) 1.4', 'Ganymede'])

VolumeM = np.array([2.1968E19,7.16E19])
PressureM = np.array([3E-10, 147E3])  # pascals
TempM = np.array([26, 94])  # kelvin
Core_PressureM = np.array([5,1.3])  # gigapascals (Venus unknown)
Sun_distanceM = np.array([1,9.5]) # au

relpermM = np.array([5000,1])  # air = 1, pure iron - 8000
BM = np.array([38/1000,0])*10**-6  # sufarce B_r
tM = np.array([708.72,15.9*24])*60*60  # seconds in planet day

TcoreM = np.array([1650,93.6])  # kelvin

GravM = np.array([1.62,1.352])  # m2s_2
massM = np.array([0.07347,0.13452])*10**24  # kg

# Attach Planets and Moons
planet = np.concatenate((planet, moon))

Volume = np.concatenate((Volume, VolumeM))
Pressure = np.concatenate((Pressure, PressureM))  # pascals
Temp = np.concatenate((Temp, TempM))  # kelvin
Core_Pressure = np.concatenate((Core_Pressure, Core_PressureM))  # gigapascals (Venus unknown)
Sun_distance = np.concatenate((Sun_distance, Sun_distanceM)) # au

relperm = np.concatenate((relperm, relpermM))  # air = 1, pure iron - 8000
B = np.concatenate((B, BM))  # sufarce B_r
t = np.concatenate((t, tM))  # seconds in planet day

Tcore = np.concatenate((Tcore, TcoreM))  # kelvin

Grav = np.concatenate((Grav, GravM))  # m2s_2
mass = np.concatenate((mass, massM)) # kg

orb2free_ratio = orbital_free_ratio(Grav) # = (e_orb + e_free) / e_orb  (or = eT / e_orb)
eT = total_electrons(mass)

# Note that orb2free_ratio = eT / e_orb
# and so e_orb = eT / orb2free_ratio

e_orb = eT * orb2free_ratio

e_free = eT - e_orb


##############################################################
#### Free electrons causing magnetic and thermal activity ####
##############################################################

q = 1.6E-19
me = 9.1E-31
c = 0.8 # specific heat capacity of liquid iron

# Working out magnetic field strength

uo = 4*np.pi*10**-7
u = relperm*uo

current = q/t

# B = u*n_free**(1/2)*current # 1/2 to reduce free electron volume to a free electron surface like a coil of wire (might not need this)

# n_free makes up whole sphere of Iron core, but only surface is calculated. To go from surace to volume divide by 3 increase power by 1.
# assume n_free volume = 4/3 pi r^3 then n_free Area = 4 pi r^2

n_freeMG = (B/(u*current))**(2) 

Eth = (e_free-n_freeMG)*me*c*(Tcore-Temp)
n_freeTH = Eth/(me*c*(Tcore-Temp))

n_free = n_freeMG + n_freeTH

print('Total electrons')
print(eT)
print('Total orbital electrons')
print(e_orb)
print('Total free electrons - gravity prediction')
print(e_free)
print('Total free electrons - magnetic & thermal prediction')
print(n_free)
print('Free electrons causing magnetic field')
print(n_freeMG)
print('Free electrons causing thermal currents')
print(n_freeTH)

# Merc, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune, Pluto, Sun + Moon, Titan

n = 12

z = np.log(e_orb[0:n].astype('float64'))

y = (n_freeMG[0:n])
y[y==0]=1E30
y = np.log(y.astype('float64'))

y2 = ((n_freeTH[0:n]))
y2 = np.log(y2.astype('float64'))

# Plots
plt.scatter(y/z,y2/z);

for i, txt in enumerate(planet[0:n]):
    plt.annotate(txt, (y[i]/z[i], y2[i]/z[i]))

plt.xlabel('Free electron mag per orbital electron')
plt.ylabel('Free electron therm per orbital electron')

# Atmosphere zone (blue dash)
plt.plot(np.linspace(1.1,1.8,10),2.05*np.ones(10),'--', color = 'lightblue', linewidth = 0.8)
plt.plot(np.linspace(1.1,1.8,10),1.95*np.ones(10),'--', color = 'k', linewidth = 0.8)
plt.plot(np.linspace(1.1,1.8,10),1.9*np.ones(10),'--', color = 'g', linewidth = 0.8)
plt.plot(np.linspace(1.1,1.8,10),1.8*np.ones(10),'--', color = 'r', linewidth = 0.8)

"""## Testing gravity equation"""

# Finding out the constant
ag = [3.7,8.8,9.8,3.7,24.7,10.5,9.0,11.7,0.49,293,1.6,1.4]

k = ag*(n_free[0:n])/(e_orb[0:n].astype('float64'))
k = np.mean(k)
k

x = np.linspace(0,1.5E26,5000)
ag = k/x
plt.plot(x,ag);

plt.xlabel('Total to orbital electron ratio')
plt.ylabel('Acceleration due to gravity')

n = 12

ratio = (n_free[0:n])/(e_orb[0:n].astype('float64'))

ag = [3.7,8.8,9.8,3.7,24.7,10.5,9.0,11.7,0.49,293,1.6,1.4][0:n]

plt.scatter(ag,np.log(np.log(np.log(np.log(ratio.astype(float))))));

x = np.linspace(min(ag),max(ag))  # 2E9 for neutron star
k = ag*ratio
k = np.mean(k)
y = k/x

plt.plot(x,np.log(np.log(np.log(np.log(y)))));

for i, txt in enumerate(planet[0:n]):
    plt.annotate(txt, (ag[i], np.log(np.log(np.log(np.log((n_free[i])/(e_orb[i])))))))

plt.ylabel('Log total electrons to orbital electron ratio')
plt.xlabel('Acceleration due to gravity')

k

n = 4

z = (e_orb[0:n].astype('float64'))

y = (n_freeMG[0:n])
y[y==0]=1E30
y = (y.astype('float64'))

y2 = ((n_free[0:n]))
y2 = (y2.astype('float64'))

plt.scatter(z/y2,9.10938356E-31*k*(z/y2))

for i, txt in enumerate(planet[0:n]):
    plt.annotate(txt, (z[i]/y2[i], 9.10938356E-31*k*(z[i]/y2[i])))

x = np.linspace(0,np.sqrt(1/n)*1E-24,5000)
F = 9.10938356E-31*k*x

plt.plot(x,F);

plt.xlabel('Orbital to total electron ratio')
plt.ylabel('Force per electron causing gravity')

k

"""# Wave mathematics

## 2D
"""

A = 1
f = 1
xL = 10

x = np.linspace(-xL,xL,1000)
y = A*np.sin(f*x)
plt.plot(x,y)

plt.xlim(-100,100)
plt.ylim(-100,100)

A = 1
f = 1
xL = 100000

x = np.linspace(-xL,xL,1000)
y = A*np.sin(f*x)
plt.plot(x,y)

plt.xlim(-100,100)
plt.ylim(-100,100)

A = 10000
f = 0.01
xL = 0.3

x = np.linspace(-xL,xL,1000)
y = A*np.sin(f*x)
plt.plot(x,y)

plt.xlim(-100,100)
plt.ylim(-100,100)

A = 1000
f = 0.001
xL = 50

x = np.linspace(-xL,xL,1000)
y = A*np.sin(f*x)
plt.plot(x,y)

plt.xlim(-100,100)
plt.ylim(-100,100)

A = 10
f = 100000000
xL = 10

x = np.linspace(-xL,xL,1000)
y = A*np.sin(f*x)
plt.plot(x,y)

plt.xlim(-100,100)
plt.ylim(-100,100)

A = 10
f = 100000000
xL = 10

u = np.linspace(-xL,xL,1000)-25

x = 10*np.sin(f*u)
y = 30*np.sin(0.5*f*u)+25
plt.plot(x,y)

plt.xlim(-100,100)
plt.ylim(-100,100)

A = 10
f = 100000000
xL = 20

x = np.linspace(-xL,xL,1000)
y = A*np.sin(f*x)+25*np.sin(np.pi*f*x)-50
plt.plot(x,y)

plt.xlim(-100,100)
plt.ylim(-100,100)

"""## 3D

### Wall
"""

A = 10
f = 1000000000
xL = 10

x = np.linspace(-xL,xL,1000)

ax = plt.axes(projection='3d')

# Data for a three-dimensional line
zline = 2/15*A*np.sin(100*f*x)
xline = 5*A*np.sin(0.1*f*x)
yline = 10*A*np.sin(f*(100*A*np.sin(f*x)))
ax.plot3D(xline, yline, zline, 'gray')

plt.xlim(-500,500)
plt.ylim(-500,500)


ax.view_init(30, 70)

A = 10
f = 100
xL = 10

x = np.linspace(-xL,xL,1000)

ax = plt.axes(projection='3d')

# Data for a three-dimensional line
zline = 2/15*A*np.sin(100*f*x)
xline = 50*A*np.sin(20*f*(100*A*np.sin(0.02*f*x)))
yline = 10*A*np.sin(0.02*f*(100*A*np.sin(0.02*f*x)))
ax.plot3D(xline, yline, zline, 'gray')


#x = 10*np.sin(f*u)
#y = 30*np.sin(0.5*f*u)+25

plt.xlim(-500,500)
plt.ylim(-500,500)


ax.view_init(30, 70)

A = 10
f = 100
xL = 10

x = np.linspace(-xL,xL,1000)

ax = plt.axes(projection='3d')

# Data for a three-dimensional line
zline = 2*A*np.sin(100*f*x)
xline = 10*A*np.sin(20*f*(100*A*np.sin(0.02*f*x)))
yline = 30*A*np.sin(0.02*f*(100*A*np.sin(0.02*f*x)))
ax.plot3D(xline, yline, zline, 'gray')


#x = 10*np.sin(f*u)
#y = 30*np.sin(0.5*f*u)+25

plt.xlim(-500,500)
plt.ylim(-500,500)


ax.view_init(30, 70)

"""### Smoother wall"""

# 8x7x2 
Ax = 4
Ay = 0.01
Az = 4

f = 100000
xL = 1

x = np.linspace(-xL,xL,1000)
ax = plt.axes(projection='3d')

# Data for a three-dimensional line
xline = Ax*np.sin(f*np.sin(f*x))*np.cos(f*np.cos(f*x))+Ax*np.sin(f*np.sin(f*x))*np.cos(f*np.cos(f*x))
yline = Ay*np.cos(f*Ay*np.cos(f*x))+Ay*np.cos(f*Ay*np.cos(f*x))
zline = Az*np.sin(f*Az*np.sin(f*x))*np.sin(f*Az*np.sin(f*x))
ax.plot3D(xline, yline, zline, 'gray')

plt.xlim(-2*(Ax+Ay),2*(Ax+Ay))
plt.ylim(-2*(Ax+Ay),2*(Ax+Ay))


ax.view_init(20, 70)

"""### Cuboid"""

# 8x7x2 cube
Ax = 8
Ay = 7
Az = 2

f = 10
xL = 10

x = np.linspace(-xL,xL,1000)

ax = plt.axes(projection='3d')

# Data for a three-dimensional line
zline = Az*np.sin(100*f*x)
xline = Ax*np.sin(20*f*(100*A*np.sin(0.02*f*x)))
yline = Ay*np.sin(0.02*f*(100*A*np.sin(0.02*f*x)))
ax.plot3D(xline, yline, zline, 'gray')

plt.xlim(-2*(Ax+Ay),2*(Ax+Ay))
plt.ylim(-2*(Ax+Ay),2*(Ax+Ay))


ax.view_init(30, 70)

A = 10

Ax = 1
Ay = 1
Az = 1

f = 1000000000
xL = 10

s = 2 # size of cubes
n = 4 # number of cubes

x = np.linspace(-xL,xL,1000)

ax = plt.axes(projection='3d')

# Data for a three-dimensional line
xline = Ax*np.sin(20*f*(100*A*np.sin(0.02*f*x)))*n
yline = Ay*np.sin(0.02*f*(100*A*np.sin(0.02*f*x)))*n
zline = Az*np.sin(100*f*x)*n
ax.plot3D(xline, yline, zline, 'gray')

# Data for a three-dimensional line
xline = Ax*np.sin(20*f*(100*A*np.sin(0.02*f*x)))*n
yline = Ay*np.sin(0.02*f*(100*A*np.sin(0.02*f*x)))*n
zline = Az*np.sin(100*f*x)*n-20
ax.plot3D(xline, yline, zline, 'gray')

# Data for a three-dimensional line
xline = Ax*np.sin(20*f*(100*A*np.sin(0.02*f*x)))*n-20
yline = Ay*np.sin(0.02*f*(100*A*np.sin(0.02*f*x)))*n
zline = Az*np.sin(100*f*x)*n
ax.plot3D(xline, yline, zline, 'gray')

# Data for a three-dimensional line
xline = Ax*np.sin(20*f*(100*A*np.sin(0.02*f*x)))*n 
yline = Ay*np.sin(0.02*f*(100*A*np.sin(0.02*f*x)))*n -20
zline = Az*np.sin(100*f*x)*n
ax.plot3D(xline, yline, zline, 'gray')

# Data for a three-dimensional line
xline = Ax*np.sin(20*f*(100*A*np.sin(0.02*f*x)))*n +20
yline = Ay*np.sin(0.02*f*(100*A*np.sin(0.02*f*x)))*n
zline = Az*np.sin(100*f*x)*n
ax.plot3D(xline, yline, zline, 'gray')

# Data for a three-dimensional line
xline = Ax*np.sin(20*f*(100*A*np.sin(0.02*f*x)))*n 
yline = Ay*np.sin(0.02*f*(100*A*np.sin(0.02*f*x)))*n +20
zline = Az*np.sin(100*f*x)*n
ax.plot3D(xline, yline, zline, 'gray')


plt.xlim(-10*(Ax+Ay),10*(Ax+Ay))
plt.ylim(-10*(Ax+Ay),10*(Ax+Ay))


ax.view_init(30, 70)

"""### Mobius strip"""

# 8x7x2 cube
Ax = 8
Ay = 5
Az = 2

f = 10000
xL = 1

x = np.linspace(-xL,xL,1000)
ax = plt.axes(projection='3d')

# Data for a three-dimensional line
xline = Ax*np.cos(f*x)*np.sin(f*x)
yline = Ay*np.sin(f*x)*np.sin(f*x)
zline = Az*np.sin(f*x)
ax.plot3D(xline, yline, zline, 'gray')

plt.xlim(-2*(Ax+Ay),2*(Ax+Ay))
plt.ylim(-2*(Ax+Ay),2*(Ax+Ay))


ax.view_init(30, 70)

"""## Using wave mathematics to model a planet"""

def model_cube(X,Y,Z, ef,space, position):
  xline = X*np.sin(20*ef*(1000*np.sin(0.02*ef*space)))*n + position[0]
  yline = Y*np.sin((0.5)*ef*(1000*np.sin(0.02*ef*space)))*n + position[1]
  zline = Z*np.sin(0.01*ef*space)*n + position[2]
  ax.plot3D(xline, yline, zline, 'gray')

def model_planet(X,Y,Z,type,space,position):
  orbital_cube = model_cube(X,Y,Z,e_orb[type],space,position)
  thermal_cube = model_cube(X,Y,Z,n_freeTH[type],space,position)
  magnetic_cube = model_cube(X,Y,Z,n_freeMG[type],space,position)
  return orbital_cube,thermal_cube, magnetic_cube

s = 1 # Amp of waves (eV of electron waves)

Ax = 1*s
Ay = 1*s
Az = 1*s

f = 1000000000
xL = 10
n = 4 # size of cubes

x = np.linspace(-xL,xL,1000)
ax = plt.axes(projection='3d')

# Sun
sun = 9

# Earth
d = 1.496E11  # 1AU
earth = 2

orbital1, thermal1, magnetic1 = model_planet(Ax,Ay,Az,sun,x,[0,0,0])
orbital2, thermal2, magnetic2 = model_planet(Ax,Ay,Az,earth,x,[d,0,0])

plt.xlim(-10*(Ax+Ay)-d,10*(Ax+Ay)+d)
plt.ylim(-10*(Ax+Ay)-d,10*(Ax+Ay)+d)
ax.view_init(30, 70)

# Gravitational Force between the planets

# This theory suggests that it's only based on orbital electrons and electrostatic force (perhaps convolution of electrostatic force)

e_orb[sun]
e_orb[earth]

# Electrostatic forces within planet F = kq1q2/r**2
k = 8.98755E9
FE = k*(1.6E-19*e_orb[earth])/((6371E3)**2)
FS =k*(1.6E-19*e_orb[sun])/((696340E3)**2)
FE+FS
#exp 3.557E22

"""# Ring mathematics

## 2D

### Orbital
"""

import numpy as np
import matplotlib.pyplot as plt

theta = np.linspace(0, 2*np.pi, 100)

r = np.sin(2*theta)

x1 = r*np.cos(theta)
x2 = r*np.sin(theta)

fig, ax = plt.subplots(1)

ax.plot(x1, x2)
ax.set_aspect(1)


plt.grid(linestyle='--')

"""### Force orbitals"""

theta = np.linspace(0, 2*np.pi, 100)

r = np.sin(10*theta)

x1 = r*np.cos(theta)
x2 = r*np.sin(theta)

plt.plot(x1, x2)


r = np.sin(theta+20)

x1 = r*np.cos(theta)
x2 = r*np.sin(theta)

plt.plot(x1, x2)


r = np.sin(theta+100)

x1 = r*np.cos(theta)
x2 = r*np.sin(theta)

plt.plot(x1, x2)


r = np.sin(theta+147)

x1 = r*np.cos(theta)
x2 = r*np.sin(theta)

plt.plot(x1, x2)

theta = np.linspace(0, 2*np.pi, 100)

r = np.sin(10*theta)+np.sin(theta+20)+np.sin(theta+100)+np.sin(theta+147)

x1 = r*np.cos(theta)
x2 = r*np.sin(theta)

plt.plot(x1, x2)

"""### Discrete polar"""

print(sum([1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1]))
plt.polar([1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0]);

plt.polar([1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]);

plt.polar([0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]);

"""## 3D"""

# setup enviornment for interactive plotting
!apt-get install -qq xvfb
!pip install pyvista panel -q

import os
os.system('/usr/bin/Xvfb :99 -screen 0 1024x768x24 &')
os.environ['DISPLAY'] = ':99'

import panel as pn
pn.extension('vtk')

# ### new cell spline example cell ###
# pn.extension('vtk')  # this needs to be at the top of each cell for some reason

# n_points = 100
# theta = np.linspace(-4 * np.pi, 4 * np.pi, n_points)
# z = np.linspace(-2, 2, n_points)
# r = z ** 2 + 1
# x = r * np.sin(theta)
# y = r * np.cos(theta)
# points = np.column_stack((x, y, z))

# # Create spline with 1000 interpolation points
# spline = pv.Spline(points, 1000)

# # add scalars to spline and plot it
# spline["scalars"] = np.arange(spline.n_points)
# tube = spline.tube(radius=0.1)
# tube.plot(smooth_shading=True, notebook=True)

"""### Proof sine in polar converges to circle"""

# setup enviornment for interactive plotting

import os
os.system('/usr/bin/Xvfb :99 -screen 0 1024x768x24 &')
os.environ['DISPLAY'] = ':99'

import panel as pn
pn.extension('vtk')

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = np.sin(100*theta)+np.sin(100*theta)
x = r * np.sin(theta)
y = r * np.cos(theta)
points = np.column_stack((x, y, z))

# Create spline with 1000 interpolation points
spline = pv.Spline(points, 100)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=0.02)
tube.plot(smooth_shading=True, notebook=True)


### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = np.sin(5*theta)+np.sin(5*theta)
x = r * np.sin(theta)
y = r * np.cos(theta)
points = np.column_stack((x, y, z))

# Create spline with 1000 interpolation points
spline = pv.Spline(points, 100)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=0.02)
tube.plot(smooth_shading=True, notebook=True)

"""### Two perpendicular force rings"""

# setup enviornment for interactive plotting

import os
os.system('/usr/bin/Xvfb :99 -screen 0 1024x768x24 &')
os.environ['DISPLAY'] = ':99'

import panel as pn
pn.extension('vtk')

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason

f = 100

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
x = r * np.sin(theta)
y = r * np.cos(theta)
points = np.column_stack((x, y, z))



theta = np.linspace(-np.pi, np.pi, n_points)
z = y 
r = r
x = x
y = np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))

# Create spline with 1000 interpolation points
spline = pv.Spline(points, 100)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=0.02)
tube.plot(smooth_shading=True, notebook=True);

"""# 3D modelling with ring mathematics"""

# setup enviornment for interactive plotting

import os
os.system('/usr/bin/Xvfb :99 -screen 0 1024x768x24 &')
os.environ['DISPLAY'] = ':99'

import panel as pn
pn.extension('vtk')

"""## Sphere"""

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 1
f = 99

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (np.sin(f*theta))+(np.sin(f*theta))
x = r * np.sin(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * np.cos(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))






# Create spline with 1000 interpolation points
spline = pv.Spline(points, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

"""## Two relative models"""

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 2
f = 2

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (np.sin(f*theta))+(np.sin(f*theta))
x = r * np.sin(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * np.cos(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))



# object 2

A = 1/2
f = 2

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (np.sin(f*theta))+(np.sin(f*theta))
x = r * np.sin(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * np.cos(theta)*A
points = np.concatenate((points,np.column_stack((x, y, z))))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))


# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

"""## Object"""

def objct(points,A,f,n_points,X,Y,Z):

  T = 1/f
  # Horizontal ring


  theta = np.linspace(-np.pi, np.pi, n_points)
  z = np.linspace(0, 0, n_points)
  r = (np.sin(f*theta))+(np.sin(f*theta))
  x = r * np.sin(theta)*A-A/(2*np.pi*f)**(f-1)
  y = r * np.cos(theta)*A
  if len(points) == 1:
    points = np.column_stack((x+X, y+Y, z+Z))
  else:
    points = np.concatenate((points,np.column_stack((x+X, y+Y, z+Z))))
    

  # Vertical ring

  theta = np.linspace(-np.pi, np.pi, n_points)
  r = np.sin(f*theta)+np.sin(f*theta)
  z = r * np.cos(theta) 
  x = A * r * np.sin(theta)
  y = A * np.linspace(0, 0, n_points)
  points = np.concatenate((points,np.column_stack((x+X, y+Y, z+Z))))


  theta = np.linspace(-np.pi, np.pi, n_points)
  r = np.sin(f*theta)+np.sin(f*theta)
  z = r * np.cos(theta) 
  x = A * r * np.sin(theta)
  y = A * np.linspace(0, 0, n_points)
  points = np.concatenate((points,np.column_stack((x+X, y+Y, z+Z))))

  import scipy

  rotation_degrees = 90
  rotation_radians = np.radians(rotation_degrees)
  rotation_axis = np.array([0, 0, 1])

  rotation_vector = rotation_radians * rotation_axis
  rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
  rotated_vec = rotation.apply(np.column_stack((x, y, z)))
  rotated_vec[:,0] = rotated_vec[:,0] + X  # xaxis
  rotated_vec[:,1] = rotated_vec[:,1] + Y  # yaxis
  rotated_vec[:,2] = rotated_vec[:,2] + Z  # zaxis
  points = np.concatenate((points,rotated_vec))

  return points

"""## Modelling"""

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 2
f = 2
n_points = 400

points = [0]

points = objct(points,A,f,n_points,0,0,0)



# object 2

A = 1/10
f = 20
X = [10,0,3]
n_points = 100

points = objct(points,A,f,n_points,X[0],X[1],X[2])


# object 3

A = 1/100
f = 10
X = [20,5,3]
n_points = 100

points = objct(points,A,f,n_points,X[0],X[1],X[2])


# object 4

A = 5
f = 90
X = [25,5,-10]
n_points = 100

points = objct(points,A,f,n_points,X[0],X[1],X[2])


# object 5

A = 2
f = 20
X = [15,15,-10]
n_points = 100

points = objct(points,A,f,n_points,X[0],X[1],X[2])


# object 6

A = 2
f = 50
X = [15,30,6]
n_points = 100

points = objct(points,A,f,n_points,X[0],X[1],X[2])


# object 6

A = 1/2
f = 10
X = [15,30,10]
n_points = 100

points = objct(points,A,f,n_points,X[0],X[1],X[2])


# object 6

A = 2
f = 20
X = [15,30,10]
n_points = 100

points = objct(points,A,f,n_points,X[0],X[1],X[2])



# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points, 10000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 1
f = 100
n_points = 1000

points = [0]

points = objct(points,A,f,n_points,0,0,0)



# object 2

A = 1
f = 100
X = [10,0,3]
n_points = 1000

points = objct(points,A,f,n_points,X[0],X[1],X[2])



# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points, 10000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

"""## Model planets"""

n = 2 # for Earth

print(np.log(eT[n]))
print(np.log(e_orb[n]))
print(np.log(e_free[n]))

print(np.log(n_freeMG[n]))
print(np.log(n_freeTH[n]))

print(np.log(Volume[n]))

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason

points = [0]

# Earth
n=2

# Magnetic electrons

A = np.log(n_freeMG[n]/e_orb[n])/10
f = np.log(n_freeMG[n])
X = [0,0,0]
n_points = 1000

points = objct(points,A,f,n_points,X[0],X[1],X[2])


# Thermal electrons

A = np.log(n_freeTH[n]/e_orb[n])/10
f = np.log(n_freeTH[n])
X = [0,0,0]
n_points = 1000

points = objct(points,A,f,n_points,X[0],X[1],X[2])


# Orbital electrons

A = 1
f = np.log(e_orb[n])
X = [0,0,0]
n_points = 1000

points = objct(points,A,f,n_points,X[0],X[1],X[2])





# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points, 10000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason

points = [0]

# Sun
n=9

# Magnetic electrons

A = np.log(n_freeMG[n])
f = np.log(n_freeMG[n])
X = [0,0,0]
n_points = 1000

points = objct(points,A,f,n_points,X[0],X[1],X[2])


# Thermal electrons

A = np.log(n_freeTH[n])
f = np.log(n_freeTH[n])
X = [0,0,0]
n_points = 1000

points = objct(points,A,f,n_points,X[0],X[1],X[2])


# Orbital electrons

A = np.log(e_orb[n])
f = np.log(e_orb[n])
X = [0,0,0]
n_points = 1000

points = objct(points,A,f,n_points,X[0],X[1],X[2])


# Earth
n=2

# Magnetic electrons

A = np.log(n_freeMG[n])
f = np.log(n_freeMG[n])
X = [1000*Sun_distance[n],0,0]
n_points = 1000

points = objct(points,A,f,n_points,X[0],X[1],X[2])


# Thermal electrons

A = np.log(n_freeTH[n])
f = np.log(n_freeTH[n])
n_points = 1000

points = objct(points,A,f,n_points,X[0],X[1],X[2])


# Orbital electrons

A = np.log(e_orb[n])
f = np.log(e_orb[n])
n_points = 1000

points = objct(points,A,f,n_points,X[0],X[1],X[2])


# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points, 10000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

"""## Forces"""

def objct(points,A,f,n_points,X,Y,Z,object_force):

  T = 1/f
  # Horizontal ring


  theta = np.linspace(-np.pi, np.pi, n_points)
  z = np.linspace(0, 0, n_points)
  r = (np.sin(f*theta))+(np.sin(f*theta)) + object_force
  x = r * np.sin(theta)*A-A/(2*np.pi*f)**(f-1)
  y = r * np.cos(theta)*A
  if len(points) == 1:
    points = np.column_stack((x+X, y+Y, z+Z))
  else:
    points = np.concatenate((points,np.column_stack((x+X, y+Y, z+Z))))
    

  # Vertical ring

  theta = np.linspace(-np.pi, np.pi, n_points)
  r = np.sin(f*theta)+np.sin(f*theta)
  z = r * np.cos(theta) 
  x = A * r * np.sin(theta)
  y = A * np.linspace(0, 0, n_points)
  points = np.concatenate((points,np.column_stack((x+X, y+Y, z+Z))))


  theta = np.linspace(-np.pi, np.pi, n_points)
  r = np.sin(f*theta)+np.sin(f*theta)
  z = r * np.cos(theta) 
  x = A * r * np.sin(theta)
  y = A * np.linspace(0, 0, n_points)
  points = np.concatenate((points,np.column_stack((x+X, y+Y, z+Z))))

  import scipy

  rotation_degrees = 90
  rotation_radians = np.radians(rotation_degrees)
  rotation_axis = np.array([0, 0, 1])

  rotation_vector = rotation_radians * rotation_axis
  rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
  rotated_vec = rotation.apply(np.column_stack((x, y, z)))
  rotated_vec[:,0] = rotated_vec[:,0] + X  # xaxis
  rotated_vec[:,1] = rotated_vec[:,1] + Y  # yaxis
  rotated_vec[:,2] = rotated_vec[:,2] + Z  # zaxis
  points = np.concatenate((points,rotated_vec))

  return points

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason

n_points = 100
points = [0]
theta = np.linspace(-np.pi, np.pi, n_points)

X2 = [2,1,0]
X1 = [8,10,0]

angle = np.arctan((X2[1]-X1[1])/(X2[0]-X1[0]))
if X2[0] == X1[0]:
  angle = 0

print(sum(X2))

a = 0
if X2[0]<X1[0]:
  a = 1

# object

A = 2
f = 10

n_points = 100

force12 = np.sin(theta+angle+a*np.pi)

points = objct(points,A,f,n_points,X1[0],X1[1],X1[2],force12)


# object

A = 2
f = 20

n_points = 100
force21 = np.sin(theta+angle+(1-a)*np.pi)

points = objct(points,A,f,n_points,X2[0],X2[1],X2[2],force21)



# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points, 10000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

"""## Planets with forces"""

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason

points = [0]

X1 = [0,0,0]
X2 = [25000*Sun_distance[n],0,0]

charge = e_orb[2]*e_orb[9]*(1.6E-19)**2
distance = np.sqrt((X2[0]-X1[0])**2+(X2[1]-X1[1])**2+(X2[2]-X1[2])**2)/1000
F = np.log(8.9875517923E9*charge/distance**2)

print(F)

angle = np.arctan((X2[1]-X1[1])/(X2[0]-X1[0]))
if X2[0] == X1[0]:
  angle = 0

a = 0
if X2[0]<X1[0]:
  a = 1

# Sun
n=9

# Magnetic electrons

A = np.log(n_freeMG[n])
f = np.log(n_freeMG[n])
X = X1
n_points = 100

force12 = F*np.sin(theta+angle+a*np.pi)

points = objct(points,A,f,n_points,X[0],X[1],X[2],force12)


# Thermal electrons

A = np.log(n_freeTH[n])
f = np.log(n_freeTH[n])
n_points = 100

points = objct(points,A,f,n_points,X[0],X[1],X[2],force12)


# Orbital electrons

A = np.log(e_orb[n])
f = np.log(e_orb[n])
n_points = 100

points = objct(points,A,f,n_points,X[0],X[1],X[2],force12)


# Earth
n=2

# Magnetic electrons

A = np.log(n_freeMG[n])
f = np.log(n_freeMG[n])
X = X2
n_points = 100

force21 = F*np.sin(theta+angle+(1-a)*np.pi)

points = objct(points,A,f,n_points,X[0],X[1],X[2],force21)


# Thermal electrons

A = np.log(n_freeTH[n])
f = np.log(n_freeTH[n])
n_points = 100

points = objct(points,A,f,n_points,X[0],X[1],X[2],force21)


# Orbital electrons

A = np.log(e_orb[n])
f = np.log(e_orb[n])
n_points = 100

points = objct(points,A,f,n_points,X[0],X[1],X[2],force21)


# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points, 10000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=10*5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

n = 2 # for Earth

print(np.log(eT[n]))
print(np.log(e_orb[n]))
print(np.log(e_free[n]))

print(np.log(n_freeMG[n]))
print(np.log(n_freeTH[n]))

print(np.log(Volume[n]))

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason

points = [0]

X1 = [0,0,0]
X2 = [1000*Sun_distance[n],0,0]

charge = e_orb[2]*e_orb[9]*(1.6E-19)**2
distance = np.sqrt((X2[0]-X1[0])**2+(X2[1]-X1[1])**2+(X2[2]-X1[2])**2)
F = np.log(8.9875517923E9*charge/distance**2)

angle = np.arctan((X2[1]-X1[1])/(X2[0]-X1[0]))
if X2[0] == X1[0]:
  angle = 0

a = 0
if X2[0]<X1[0]:
  a = 1

# Sun
n=9

# Magnetic electrons

A = np.log(n_freeMG[n])
f = np.log(n_freeMG[n])
X = X1
n_points = 100

force12 = F*np.sin(theta+angle+a*np.pi)

points = objct(points,A,f,n_points,X[0],X[1],X[2],force12)


# Thermal electrons

A = np.log(n_freeTH[n])
f = np.log(n_freeTH[n])
n_points = 100

points = objct(points,A,f,n_points,X[0],X[1],X[2],force12)


# Orbital electrons

A = np.log(e_orb[n])
f = np.log(e_orb[n])
n_points = 100

points = objct(points,A,f,n_points,X[0],X[1],X[2],force12)


# Earth
n=2

# Magnetic electrons

A = np.log(n_freeMG[n])
f = np.log(n_freeMG[n])
X = X2
n_points = 100

force21 = F*np.sin(theta+angle+(1-a)*np.pi)

points = objct(points,A,f,n_points,X[0],X[1],X[2],force21)


# Thermal electrons

A = np.log(n_freeTH[n])
f = np.log(n_freeTH[n])
n_points = 100

points = objct(points,A,f,n_points,X[0],X[1],X[2],force21)


# Orbital electrons

A = np.log(e_orb[n])
f = np.log(e_orb[n])
n_points = 100

points = objct(points,A,f,n_points,X[0],X[1],X[2],force21)


# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points, 10000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

"""## Particles"""

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 20
f = 40

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (np.sin(f*theta))+(np.sin(f*theta))
x = r * np.sin(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * np.cos(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))



# object 2

A = 1/20
f = 20

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (np.sin(f*theta))+(np.sin(f*theta))
x = r * np.sin(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * np.cos(theta)*A
points = np.concatenate((points,np.column_stack((x, y, z))))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))


# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 20
f = 40

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (np.sin(f*theta))+(np.sin(f*theta))
x = r * np.sin(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * np.cos(theta)*A
points = np.column_stack((x+2*A, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))



# object 2

A = 1/20
f = 20

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (np.sin(f*theta))+(np.sin(f*theta))
x = r * np.sin(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * np.cos(theta)*A
points = np.concatenate((points,np.column_stack((x, y, z))))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))


# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 20
f = 10

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (np.sin(f*theta))+(np.sin(f*theta))
x = r * np.sin(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * np.cos(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))



# object 2

A = 1/20
f = 20

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (np.sin(f*theta))+(np.sin(f*theta))
x = r * np.sin(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * np.cos(theta)*A
points = np.concatenate((points,np.column_stack((x, y, z))))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))


# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

"""## Curved Line"""

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason

A = 1
f = 99

T = 1/f

# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (np.sin(f*theta))+(np.sin(f*theta))
x = r * np.sin(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * np.cos(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x+A, y, z))) # changes to line by translation of A


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))

# Create spline with 1000 interpolation points
spline = pv.Spline(points, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason

A = 9
f = 99

T = 1/f

# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (np.sin(f*theta))+(np.sin(f*theta))
x = r * np.sin(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * np.cos(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x-A, y, z))) # changes to line


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))



# Create spline with 1000 interpolation points
spline = pv.Spline(points, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

"""# Exponential quantum relativity

## Initialise
"""

import numpy as np
import matplotlib.pyplot as plt

def factorial(x):
  factorial = 1
  if int(x) >= 1:
    for i in range (1,int(x)+1):
      factorial = factorial * i
  return factorial

def exp(x,n):
  exp = 0
  for i in range (0,n):
    exp += (1/factorial(i))
  return exp**x

n = 100

def E(x,n):
  return W*exp(2*f*np.pi*x,n)

def E2(x,n):
  return W*exp(2*f*np.pi*x-0.5j*np.pi,n)

def S(x):
  return W*exp(2*f*np.pi*x*1j-np.pi*0.5j,n)

def C(x):
  return W*exp(2*f*np.pi*x*1j,n)

def Electromagnetism(x):
  return S(E(x))

def ElectronWave(x):
  return C(C(x))

def LifeWave(x):
  return S(C(x))

W = 1 # 1/1000 Volumatic # 10 lines # 25 particles # 1 normal
f = 1
L = 1000

# x = np.linspace(0, 1, L)
# w1/10, f1/10 (Default/volume)
# w1, f1 (Default/string)
# w5, f5 (Default/particles)

# w1,f100 (DNA)
# w25,f25,f100 (Particles)
# w10,f10,f99 (Particles/Lines)
# w 1/1000,f1, f25 (Volumes)

# w1, f1/(2*np.pi) x = np.linspace(np.pi/2, 5*np.pi/2, L)

x = np.linspace(0, 1, L)
x = np.linspace(np.pi/2, 5*np.pi/2, L)

phase = -0/(4*f)

fig, axs = plt.subplots(3, 2)

axs[0,0].plot(E(x+phase,n)) # exponential
axs[1,1].plot(C(x+phase)) # cos
axs[1,0].plot(S(x+phase)) # sine

axs[0,1].plot(S(E(x+phase,n))) # electromagnetic spectrum

axs[2,1].plot(C(C(x+phase))) # electron beat
axs[2,0].plot(S(C(x+phase))) # heart beat

"""## Sphere"""

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 1
f = 2

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (S(f*theta))+(S(f*theta))
x = r * S(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * C(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))





import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))






# Create spline with 1000 interpolation points
spline = pv.Spline(points.real, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 1
f = 99

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (S(f*theta))+(S(f*theta))
x = r * S(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * C(theta)*A
points = np.column_stack((x, y, z))




# Create spline with 1000 interpolation points
spline = pv.Spline(points.real, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 1
f = 5

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (S(f*theta))+(S(f*theta))
x = r * S(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * C(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))






# Create spline with 1000 interpolation points
spline = pv.Spline(points.real, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 1/10
f = 100

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (S(f*theta))+(S(f*theta))
x = r * S(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * C(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



# Create spline with 1000 interpolation points
spline = pv.Spline(points.real, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 1/2
f = 2

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (S(f*theta))+(S(f*theta))
x = r * S(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * C(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



# Create spline with 1000 interpolation points
spline = pv.Spline(points.real, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 1/10
f = 10

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (S(f*theta))+(S(f*theta))
x = r * S(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * C(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



# Create spline with 1000 interpolation points
spline = pv.Spline(points.real, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

"""## Rings

### Real
"""

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 1
f = 1

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (S(f*theta))+(S(f*theta))
x = r * S(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * C(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))



# Create spline with 1000 interpolation points
spline = pv.Spline(points.real, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 1
f = 25

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (S(f*theta))+(S(f*theta))
x = r * S(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * C(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))



# Create spline with 1000 interpolation points
spline = pv.Spline(points.real, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 10
f = 20

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (S(f*theta))+(S(f*theta))
x = r * S(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * C(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))



# Create spline with 1000 interpolation points
spline = pv.Spline(points.real, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

"""### Imaginary"""

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 1
f = 1

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (S(f*theta))+(S(f*theta))
x = r * S(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * C(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))






# Create spline with 1000 interpolation points
spline = pv.Spline(points.imag, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 1
f = 25

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (S(f*theta))+(S(f*theta))
x = r * S(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * C(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))



# Create spline with 1000 interpolation points
spline = pv.Spline(points.imag, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

"""## Two relative models"""

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 2
f = 2

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (S(f*theta))+(S(f*theta))
x = r * S(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * C(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))



# object 2

A = 1/2
f = 2

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (S(f*theta))+(S(f*theta))
x = r * S(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * C(theta)*A
points = np.concatenate((points,np.column_stack((x, y, z))))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))


# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points.real, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

"""## Object"""

def objct2(points,A,f,n_points,X,Y,Z):

  T = 1/f
  # Horizontal ring


  theta = np.linspace(-np.pi, np.pi, n_points)
  z = np.linspace(0, 0, n_points)
  r = (S(f*theta))+(S(f*theta))
  x = r * S(theta)*A-A/(2*np.pi*f)**(f-1)
  y = r * C(theta)*A
  if len(points) == 1:
    points = np.column_stack((x+X, y+Y, z+Z))
  else:
    points = np.concatenate((points,np.column_stack((x+X, y+Y, z+Z))))
    

  # Vertical ring

  theta = np.linspace(-np.pi, np.pi, n_points)
  r = S(f*theta)+S(f*theta)
  z = r * C(theta) 
  x = A * r * S(theta)
  y = A * np.linspace(0, 0, n_points)
  points = np.concatenate((points,np.column_stack((x+X, y+Y, z+Z))))


  theta = np.linspace(-np.pi, np.pi, n_points)
  r = S(f*theta)+S(f*theta)
  z = r * C(theta) 
  x = A * r * S(theta)
  y = A * np.linspace(0, 0, n_points)
  points = np.concatenate((points,np.column_stack((x+X, y+Y, z+Z))))

  import scipy

  rotation_degrees = 90
  rotation_radians = np.radians(rotation_degrees)
  rotation_axis = np.array([0, 0, 1])

  rotation_vector = rotation_radians * rotation_axis
  rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
  rotated_vec = rotation.apply(np.column_stack((x, y, z)))
  rotated_vec[:,0] = rotated_vec[:,0] + X  # xaxis
  rotated_vec[:,1] = rotated_vec[:,1] + Y  # yaxis
  rotated_vec[:,2] = rotated_vec[:,2] + Z  # zaxis
  points = np.concatenate((points,rotated_vec))

  return points

"""## Modelling"""

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 2
f = 2
n_points = 400

points = [0]

points = objct2(points,A,f,n_points,0,0,0)



# object 2

A = 1/10
f = 20
X = [10,0,3]
n_points = 100

points = objct2(points,A,f,n_points,X[0],X[1],X[2])


# object 3

A = 1/100
f = 10
X = [20,5,3]
n_points = 100

points = objct2(points,A,f,n_points,X[0],X[1],X[2])


# object 4

A = 5
f = 90
X = [25,5,-10]
n_points = 100

points = objct2(points,A,f,n_points,X[0],X[1],X[2])


# object 5

A = 2
f = 20
X = [15,15,-10]
n_points = 100

points = objct2(points,A,f,n_points,X[0],X[1],X[2])


# object 6

A = 2
f = 50
X = [15,30,6]
n_points = 100

points = objct2(points,A,f,n_points,X[0],X[1],X[2])


# object 6

A = 1/2
f = 10
X = [15,30,10]
n_points = 100

points = objct2(points,A,f,n_points,X[0],X[1],X[2])


# object 6

A = 2
f = 20
X = [15,30,10]
n_points = 100

points = objct2(points,A,f,n_points,X[0],X[1],X[2])



# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points.real, 10000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

"""## Model planets"""

n = 2 # for Earth

print(np.log(eT[n]))
print(np.log(e_orb[n]))
print(np.log(e_free[n]))

print(np.log(n_freeMG[n]))
print(np.log(n_freeTH[n]))

print(np.log(Volume[n]))

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason

points = [0]

# Earth
n=2

# Magnetic electrons

A = np.log(n_freeMG[n]/e_orb[n])/10
f = np.log(n_freeMG[n])
X = [0,0,0]
n_points = 1000

points = objct2(points,A,f,n_points,X[0],X[1],X[2])


# Thermal electrons

A = np.log(n_freeTH[n]/e_orb[n])/10
f = np.log(n_freeTH[n])
X = [0,0,0]
n_points = 1000

points = objct2(points,A,f,n_points,X[0],X[1],X[2])


# Orbital electrons

A = 1
f = np.log(e_orb[n])
X = [0,0,0]
n_points = 1000

points = objct2(points,A,f,n_points,X[0],X[1],X[2])





# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points.imag, 10000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason

points = [0]

# Sun
n=9

# Magnetic electrons

A = np.log(n_freeMG[n])
f = np.log(n_freeMG[n])
X = [0,0,0]
n_points = 1000

points = objct2(points,A,f,n_points,X[0],X[1],X[2])


# Thermal electrons

A = np.log(n_freeTH[n])
f = np.log(n_freeTH[n])
X = [0,0,0]
n_points = 1000

points = objct2(points,A,f,n_points,X[0],X[1],X[2])


# Orbital electrons

A = np.log(e_orb[n])
f = np.log(e_orb[n])
X = [0,0,0]
n_points = 1000

points = objct2(points,A,f,n_points,X[0],X[1],X[2])


# Earth
n=2

# Magnetic electrons

A = np.log(n_freeMG[n])
f = np.log(n_freeMG[n])
X = [10000*Sun_distance[n],0,0]
n_points = 1000

points = objct2(points,A,f,n_points,X[0],X[1],X[2])


# Thermal electrons

A = np.log(n_freeTH[n])
f = np.log(n_freeTH[n])
n_points = 1000

points = objct2(points,A,f,n_points,X[0],X[1],X[2])


# Orbital electrons

A = np.log(e_orb[n])
f = np.log(e_orb[n])
n_points = 1000

points = objct2(points,A,f,n_points,X[0],X[1],X[2])


# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points.real, 10000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

"""## Forces"""

def objct2(points,A,f,n_points,X,Y,Z,object_force):

  T = 1/f
  # Horizontal ring


  theta = np.linspace(-np.pi, np.pi, n_points)
  z = np.linspace(0, 0, n_points)
  r = (S(f*theta))+(S(f*theta)) + object_force
  x = r * S(theta)*A-A/(2*np.pi*f)**(f-1)
  y = r * C(theta)*A
  if len(points) == 1:
    points = np.column_stack((x+X, y+Y, z+Z))
  else:
    points = np.concatenate((points,np.column_stack((x+X, y+Y, z+Z))))
    

  # Vertical ring

  theta = np.linspace(-np.pi, np.pi, n_points)
  r = S(f*theta)+S(f*theta)
  z = r * C(theta) 
  x = A * r * S(theta)
  y = A * np.linspace(0, 0, n_points)
  points = np.concatenate((points,np.column_stack((x+X, y+Y, z+Z))))


  theta = np.linspace(-np.pi, np.pi, n_points)
  r = S(f*theta)+S(f*theta)
  z = r * C(theta) 
  x = A * r * S(theta)
  y = A * np.linspace(0, 0, n_points)
  points = np.concatenate((points,np.column_stack((x+X, y+Y, z+Z))))

  import scipy

  rotation_degrees = 90
  rotation_radians = np.radians(rotation_degrees)
  rotation_axis = np.array([0, 0, 1])

  rotation_vector = rotation_radians * rotation_axis
  rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
  rotated_vec = rotation.apply(np.column_stack((x, y, z)))
  rotated_vec[:,0] = rotated_vec[:,0] + X  # xaxis
  rotated_vec[:,1] = rotated_vec[:,1] + Y  # yaxis
  rotated_vec[:,2] = rotated_vec[:,2] + Z  # zaxis
  points = np.concatenate((points,rotated_vec))

  return points

"""### 2 bodies"""

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason

n_points = 100
points = [0]
theta = np.linspace(-np.pi, np.pi, n_points)

X2 = [10,1,8]
X1 = [2,10,0]


if X2[0] != X1[0]:
  angle = np.arctan((X2[1]-X1[1])/(X2[0]-X1[0]))
else:
  angle = 0

print(np.sum(X2))

a = 0
if X2[0]<X1[0]:
  a = 1

# object

A = 2
f = 10



force12 = S(theta+angle+a*np.pi)

points = objct2(points,A,f,n_points,X1[0],X1[1],X1[2],force12)


# object

A = 2
f = 10


force21 = S(theta+angle+(1-a)*np.pi)

points = objct2(points,A,f,n_points,X2[0],X2[1],X2[2],force21)



# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points.real, 10000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

"""## Planets with forces"""

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason

points = [0]

X1 = [0,0,0]
X2 = [Sun_distance[n],0,0]

distance = np.sqrt((X2[0]-X1[0])**2+(X2[1]-X1[1])**2+(X2[2]-X1[2])**2)

cm = n_freeMG[2]*n_freeMG[9]*(1.6E-19)**2
cth = n_freeTH[2]*n_freeTH[9]*(1.6E-19)**2
co = e_orb[2]*e_orb[9]*(1.6E-19)**2

Fm = np.log(8.9875517923E9*cm/distance**2)*0
Fth = np.log(8.9875517923E9*cth/distance**2)*0
Fo = np.log(8.9875517923E9*co/distance**2)


if X2[0] != X1[0]:
  angle = np.arctan((X2[1]-X1[1])/(X2[0]-X1[0]))
else:
  angle = 0

a = 0
if X2[0]<X1[0]:
  a = 1

# Sun
n=9

# Magnetic electrons

A = np.log(n_freeMG[n])
f = np.log(n_freeMG[n])
X = X1
n_points = 100

forcem12 = Fm*S(theta+angle+a*np.pi)

points = objct2(points,A,f,n_points,X[0],X[1],X[2],forcem12)


# Thermal electrons

A = np.log(n_freeTH[n])
f = np.log(n_freeTH[n])
n_points = 100

forceth12 = Fth*S(theta+angle+a*np.pi)

points = objct2(points,A,f,n_points,X[0],X[1],X[2],forceth12)


# Orbital electrons

A = np.log(e_orb[n])
f = np.log(e_orb[n])
n_points = 100

forceo12 = Fo*S(theta+angle+a*np.pi)

points = objct2(points,A,f,n_points,X[0],X[1],X[2],forceo12)


# Earth
n=2

# Magnetic electrons

A = np.log(n_freeMG[n])
f = np.log(n_freeMG[n])
X = X2
n_points = 100

forcem21 = Fm*S(theta+angle+(1-a)*np.pi)

points = objct2(points,A,f,n_points,X[0],X[1],X[2],forcem21)


# Thermal electrons

A = np.log(n_freeTH[n])
f = np.log(n_freeTH[n])
n_points = 100

forceth21 = Fth*S(theta+angle+(1-a)*np.pi)

points = objct2(points,A,f,n_points,X[0],X[1],X[2],forceth21)


# Orbital electrons

A = np.log(e_orb[n])
f = np.log(e_orb[n])
n_points = 100

forceo21 = Fo*S(theta+angle+(1-a)*np.pi)

points = objct2(points,A,f,n_points,X[0],X[1],X[2],forceo21)


# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points.real, 10000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=10*5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

n = 2 # for Earth

print(np.log(eT[n]))
print(np.log(e_orb[n]))
print(np.log(e_free[n]))

print(np.log(n_freeMG[n]))
print(np.log(n_freeTH[n]))

print(np.log(Volume[n]))

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason

points = [0]

X1 = [0,0,0]
X2 = [1000*Sun_distance[n],0,0]

charge = e_orb[2]*e_orb[9]*(1.6E-19)**2
distance = np.sqrt((X2[0]-X1[0])**2+(X2[1]-X1[1])**2+(X2[2]-X1[2])**2)
F = np.log(8.9875517923E9*charge/distance**2)

angle = np.arctan((X2[1]-X1[1])/(X2[0]-X1[0]))
if X2[0] == X1[0]:
  angle = 0

a = 0
if X2[0]<X1[0]:
  a = 1

# Sun
n=9

# Magnetic electrons

A = np.log(n_freeMG[n])
f = np.log(n_freeMG[n])
X = X1
n_points = 100

force12 = F*np.sin(theta+angle+a*np.pi)

points = objct2(points,A,f,n_points,X[0],X[1],X[2],force12)


# Thermal electrons

A = np.log(n_freeTH[n])
f = np.log(n_freeTH[n])
n_points = 100

points = objct2(points,A,f,n_points,X[0],X[1],X[2],force12)


# Orbital electrons

A = np.log(e_orb[n])
f = np.log(e_orb[n])
n_points = 100

points = objct2(points,A,f,n_points,X[0],X[1],X[2],force12)


# Earth
n=2

# Magnetic electrons

A = np.log(n_freeMG[n])
f = np.log(n_freeMG[n])
X = X2
n_points = 100

force21 = F*np.sin(theta+angle+(1-a)*np.pi)

points = objct2(points,A,f,n_points,X[0],X[1],X[2],force21)


# Thermal electrons

A = np.log(n_freeTH[n])
f = np.log(n_freeTH[n])
n_points = 100

points = objct2(points,A,f,n_points,X[0],X[1],X[2],force21)


# Orbital electrons

A = np.log(e_orb[n])
f = np.log(e_orb[n])
n_points = 100

points = objct2(points,A,f,n_points,X[0],X[1],X[2],force21)


# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points.real, 10000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

"""## Particles"""

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 20
f = 40

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (S(f*theta))+(S(f*theta))
x = r * S(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * C(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * np.cos(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))



# object 2

A = 1/20
f = 20

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (S(f*theta))+(S(f*theta))
x = r * S(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * C(theta)*A
points = np.concatenate((points,np.column_stack((x, y, z))))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))


# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points.real, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 20
f = 10

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (np.sin(f*theta))+(np.sin(f*theta))
x = r * np.sin(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * np.cos(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))



# object 2

A = 1/20
f = 20

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (np.sin(f*theta))+(np.sin(f*theta))
x = r * np.sin(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * np.cos(theta)*A
points = np.concatenate((points,np.column_stack((x, y, z))))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))


# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

"""## Curved Line"""

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason

A = 9
f = 99

T = 1/f

# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (np.sin(f*theta))+(np.sin(f*theta))
x = r * np.sin(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * np.cos(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x-A, y, z))) # changes to line


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))



# Create spline with 1000 interpolation points
spline = pv.Spline(points, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

"""# Exponential mathematics

## Initialise
"""

import numpy as np
import matplotlib.pyplot as plt

def factorial(x):
  factorial = 1
  if int(x) >= 1:
    for i in range (1,int(x)+1):
      factorial = factorial * i
  return factorial

def exp(x,n):
  exp = 0
  for i in range (0,n):
    exp += (1/factorial(i))
  return exp**x

n = 100

def E(x,n):
  return W*exp(2*f*np.pi*x,n)

def E2(x,n):
  return W*exp(2*f*np.pi*x-0.5j*np.pi,n)

def S(x):
  return W*exp(2*f*np.pi*x*1j-np.pi*0.5j,n)

def C(x):
  return W*exp(2*f*np.pi*x*1j,n)

def Electromagnetism(x):
  return S(E(x,n))

def ElectronWave(x):
  return C(C(x))

def LifeWave(x):
  return S(C(x))

"""## C wave and S wave comparison to cos and sine"""

W = 1 # 1/1000 Volumatic # 10 lines # 25 particles # 1 normal
f = 1/(2*np.pi)
L = 10000

# w1/10, f1/10 (Default/volume)
# w1, f1 (Default/string)
# w5, f5 (Default/particles)

# w1,f100 (DNA)
# w25,f25,f100 (Particles)
# w10,f10,f99 (Particles/Lines)
# w 1/1000,f1, f25 (Volumes)


x = np.linspace(0, 2*np.pi, L)
#x = np.linspace(0, 1, L)

phase = -0/(4*f)

fig, axs = plt.subplots(3, 2)
plt.subplots_adjust(wspace=0.3, hspace=0.5)

axs[0,0].plot(x,E(x+phase,n)) # exponential
axs[1,1].plot(x,C(x+phase)) # cos
axs[1,0].plot(x,S(x+phase)) # sine

axs[0,1].plot(x,S(E(x+phase,n))) # electromagnetic spectrum

axs[2,1].plot(x,C(C(x+phase))) # electron beat
axs[2,0].plot(x,S(C(x+phase))) # heart beat

plt.plot(x,S(x))
plt.plot(x,np.sin(x))

plt.plot(x,C(x))
plt.plot(x,np.cos(x))

plt.plot(C(x)**2+S(x)**2)

plt.plot(np.cos(x)**2+np.sin(x)**2)

plt.plot(C(x)**2)
plt.plot(S(x)**2)

plt.plot(np.sin(x)**2)
plt.plot(np.cos(x)**2)

plt.plot(np.sin(x*1j))
#plt.plot(np.cos(x*1j))
#plt.plot(C(x*1j))
#plt.plot(S(x*1j))

"""## Discrete exponential increase"""

W = 1 # 1/1000 Volumatic # 10 lines # 25 particles # 1 normal
f = 100
L = 10000

# w1/10, f1/10 (Default/volume)
# w1, f1 (Default/string)
# w5, f5 (Default/particles)

# w1,f100 (DNA)
# w25,f25,f100 (Particles)
# w10,f10,f99 (Particles/Lines)
# w 1/1000,f1, f25 (Volumes)


x = np.linspace(0, 1, L)
#x = np.linspace(np.pi/2, 5*np.pi/2, L)

phase = -0/(4*f)

fig, axs = plt.subplots(3, 2)

axs[0,0].plot(x,E(x+phase,n)) # exponential
axs[1,1].plot(x,C(x+phase)) # cos
axs[1,0].plot(x,S(x+phase)) # sine

axs[0,1].plot(x,S(E(x+phase,n))) # electromagnetic spectrum

axs[2,1].plot(x,C(C(x+phase))) # electron beat
axs[2,0].plot(x,S(C(x+phase))) # heart beat

plt.plot(x,C(x)**2+S(x)**2)

"""## Comparison to ECG data

### Initiate
"""

from google.colab import drive
drive.mount('/content/drive')

#%cd /content/drive/MyDrive/Machine Learning Ideas/ECG data

# ECG data
with open("/content/drive/MyDrive/Machine Learning Ideas/Quantum Relativity/ECG data/mitbih_train.csv") as file_name:
    ecg_array = np.loadtxt(file_name, delimiter=",")

"""### Analysis"""

plt.plot(ecg_array[0,:]);

W = 1/2 # 1/1000 Volumatic # 10 lines # 25 particles # 1 normal
W2 = 0.0022

a = 1  #  stretch in x
c = 0  # elevation

f = 2.2
L = 188

x = np.linspace(0, 1, L)

phase = 0.35 #-0/(4*f)

plt.plot(x*180,W2*S(C(a*x+phase))+c, linestyle = '--', label = 'Generated'); # heart beat

plt.plot(ecg_array[0,:], label = 'ECG');

plt.legend()

W = 1/2 # 1/1000 Volumatic # 10 lines # 25 particles # 1 normal
f = 2.2 

W2 = 0.0028

a1 = 1  #  stretch in x
c1 = 0  # elevation
a2 = 0.4  #  stretch in x
c2 = 0.1  # elevation


L = 188
x = np.linspace(0, 1, L)

phase1 = 0.345 #-0/(4*f)
phase2 = 0.225 #-0/(4*f)

plt.plot(x*180,W2*S(C(a1*x+phase1))+c1, linestyle = '--', label = 'Generated'); # heart beat

W = 1/4
f = 2.2*2
plt.plot(x*180,W2*C(C(a2*x+phase2))+c2, linestyle = '--', label = 'Generated'); # electronic beat

plt.plot(ecg_array[0,:], label = 'ECG');

plt.legend()

L = 188
x = np.linspace(0, 1, L)

W = 1/2 # 1/1000 Volumatic # 10 lines # 25 particles # 1 normal
f = 2.2 

W2 = 0.0028
a1 = 1  #  stretch in x
c1 = 0  # elevation
phase1 = 0.345

beat1 = W2*S(C(a1*x+phase1))+c1

W = 1/4
f = 2.2*2

W3 = 0.0022
a2 = 0.4  #  stretch in x
c2 = 0.1  # elevation
phase2 = 0.225

beat2 = W3*C(C(a2*x+phase2))+c2


plt.plot(x*180,beat1+beat2, linestyle = '--', label = 'Generated'); # electronic beat
plt.plot(ecg_array[0,:], label = 'ECG');
plt.legend()

"""### Machine learning

#### Initialise
"""

# Machine learning to update parameters efficiently

def beat_gen_analysis(W1,W2,a,c,f1,phase,ecg):


  n = 100

  def E(x,n):
    return W*exp(2*f*np.pi*x,n)

  def E2(x,n):
    return W*exp(2*f*np.pi*x-0.5j*np.pi,n)

  def S(x):
    return W*exp(2*f*np.pi*x*1j-np.pi*0.5j,n)

  def C(x):
    return W*exp(2*f*np.pi*x*1j,n)

  def Electromagnetism(x):
    return S(E(x))

  def ElectronWave(x):
    return C(C(x))

  def LifeWave(x):
    return S(C(x))

  W = W1
  f = f1
  
  L = 188
  x = np.linspace(0, 1, L)

  #plt.plot(x*180,W2*S(C(a*x+phase))+c, linestyle = '--', label = 'Generated'); # heart beat
  #plt.plot(ecg, label = 'ECG');
  plt.legend()


  return W2*S(C(a*x+phase))+c

# Beat1

beat1 = beat_gen_analysis(0.5,0.0028,1,0,2.2,0.345,ecg_array[0,:])
                       # (W, W2,  a,c,  f,phase,ecg)


# Beat2

beat2 = beat_gen_analysis(0.25,0.0022,0.4,0.1,4.4,0.225,ecg_array[0,:])
                        # (W, W2,  a,c,  f,phase,ecg)

plt.plot(x*180,beat1+beat2, linestyle = '--', label = 'Generated');
plt.plot(ecg_array[0,:], label = 'ECG');

def heartbeat(W1, W2,  a1,c1,  f1,phase1, W12, W22,  a2,c2,  f2,phase2,ecg):
  # Beat1

  beat1 = beat_gen_analysis(W1, W2,  a1,c1,  f1,phase1,ecg)
                        # (W, W2,  a,c,  f,phase,ecg)


  # Beat2

  beat2 = beat_gen_analysis(W12, W22,  a2,c2,  f2,phase2,ecg)
                          # (W, W2,  a,c,  f,phase,ecg)

  plt.plot(x*180,beat1+beat2, linestyle = '--', label = 'Generated');
  plt.plot(ecg_array[0,:], label = 'ECG');

  return beat1+beat2

W1, W2,  a1,c1,  f1,phase1 = 0.5,0.0028,1,0,2.2,0.345
W12, W22,  a2,c2,  f2,phase2,ecg = 0.25,0.0022,0.4,0.1,4.4,0.225,ecg_array[0,:]

hbeat = heartbeat(W1, W2,  a1,c1,  f1,phase1, W12, W22,  a2,c2,  f2,phase2,ecg)
               # (W1, W2,  a1,c1,  f1,phase1, W12, W22,  a2,c2,  f2,phase2,ecg)

"""#### Variable training"""

# Beat1

W = 1/2 
f = 2.2 

beat1 = beat_gen_analysis(0.5,0.0028,1,0,2.2,0.345,ecg_array[0,:])
                       # (W, W2,  a,c,  f,phase,ecg)


# Beat2

W = 0.25
f = 4.4 

beat2 = beat_gen_analysis(0.25,0.0022,0.4,0.1,4.4,0.225,ecg_array[0,:])
                        # (W, W2,  a,c,  f,phase,ecg)

plt.plot(x*180,beat1+beat2, linestyle = '--', label = 'Generated');
plt.plot(ecg_array[0,:], label = 'ECG');

"""## Comparison to Electromagnetic spectrum"""

W = 1 # 1/1000 Volumatic # 10 lines # 25 particles # 1 normal
f = 1
L = 10000

# w1/10, f1/10 (Default/volume)
# w1, f1 (Default/string)
# w5, f5 (Default/particles)

# w1,f100 (DNA)
# w25,f25,f100 (Particles)
# w10,f10,f99 (Particles/Lines)
# w 1/1000,f1, f25 (Volumes)


x = np.linspace(0, 1, L)
#x = np.linspace(np.pi/2, 5*np.pi/2, L)

phase = -0/(4*f)

plt.plot(x,S(E(x+phase,n))) # electromagnetic spectrum

"""# Exponential wave mathematics"""

W = 1
f = 4
x = np.linspace(0,1,100)

plt.plot(x,(x))
plt.plot(x,(2*np.pi*x))
plt.plot(x,(2*np.pi*f*x))
plt.plot(x,(2*np.pi*f*x*1J))
#plt.plot(x,np.exp(2*np.pi*f*x))

x = 1
y = 1

sum = np.zeros(10000)

for K in range(1,10000):
    y *= x/K
    sum[K] = y

2*np.sum(sum)

"""## Exponential function

### Opposite
"""

def exp2(x):
  x = np.array(x)
  accuracy = 100

  y = np.ones(len(x))
  if isinstance(x[0], complex):
    y = np.ones(len(x))*1j
    
  y2 = np.zeros((accuracy,len(x)))

  for K in range(1,accuracy):
      y*= x/K
      for i in range(0,len(x)):
        y2[K,i] = np.sum(y[i],axis=0)

  return y2

x = np.linspace(-10,10,50)
plt.plot(x,np.transpose(exp2(1j*x)));

plt.plot(x,np.transpose(exp2(x)));

plt.plot(x,np.transpose(exp2(1j*x)));

f = 1

plt.plot(x,np.transpose(exp2(2*np.pi*f*x*1j)));

"""### Normal"""

accuracy = 1000

x = np.array([1])

y = np.ones(len(x))
y2 = np.zeros((accuracy,len(x)))

for K in range(1,accuracy):
    y *= x/K
    for i in range(0,len(x)):
      y2[K,i] = y[i]

np.sum(y2,axis=0)+1

def exp(x):
  x = np.array(x)
  accuracy = 1000

  y = np.ones(len(x))
  if isinstance(x[0], complex):
    y = np.ones(len(x))*1j
    
  y2 = np.zeros((accuracy,len(x)))

  for K in range(1,accuracy):
      y *= x/K
      for i in range(0,len(x)):
        y2[K,i] = y[i]

  return np.sum(y2,axis=0)

def log(x):
  x = np.array(x)
  accuracy = 1000

  y = np.ones(len(x))
  if isinstance(x[0], complex):
    y = np.ones(len(x))*1j
    
  y2 = 0

  for K in range(1,accuracy):
    y2 += -(-x**K)/K

  return y2

x = np.linspace(0,100,1000)
plt.plot(x,log(x+1))

exp([1j*np.pi])

x = np.linspace(0,2*np.pi,100)

f = 10/(2*np.pi)
W = 1

y = W*exp(-2*np.pi*f*x*1j)

plt.plot(x,y)

# sine and cos

x = np.linspace(0,1,100)

f = 5
W = 1

y = W*exp(-2*np.pi*f*x*1j-0.5*1j*np.pi)

plt.plot(x,y)

y = W*exp(-2*np.pi*f*x*1j)

plt.plot(x,y)

plt.plot((W*exp(-2*np.pi*f*x*1j)**2+W*exp(-2*np.pi*f*x*1j-0.5*1j*np.pi)**2)[0:round(max(x))+1]);

x = np.linspace(0,2*np.pi,1000)

f = 2*np.pi/(2*np.pi)
W = 1

y = np.transpose(W*exp(-2*np.pi*f*x*1J)-exp([np.pi*1j]))

plt.plot(x,y)

plt.plot(x,np.sin(2*np.pi*x))

"""### Orbital becoming thermal"""

x = np.linspace(-4*np.pi,4*np.pi,1000)

f = 1*np.pi/(2*np.pi)  # 0.1, 2 or 10*np.pi/(2*np.pi)
W = 1

y = np.transpose(W*exp2(-2*np.pi*f*x*1J)-exp2([np.pi*1j]))

plt.plot(x,y);

#plt.polar(x,np.sin(f*2*np.pi*x))

"""#### Coil of wire"""

x = np.linspace(-4*np.pi,4*np.pi,1000)

f = 0.99*np.pi/(2*np.pi)  # 0.1, 2 or 10*np.pi/(2*np.pi)
W = 1

y = np.transpose(W*exp(-2*np.pi*f*x*1J)-exp([np.pi*1j]))

plt.plot(x,y);

#plt.polar(x,np.sin(f*2*np.pi*x))

plt.polar(x,y);

"""## Waves"""

# W = 2
# f = 2
# x = np.linspace(0,2,10000)+1

# y = W*exp(2*np.pi*f*x*1J-0.5J*np.pi)

# plt.plot(x,y)


W = 3
f = 3
x = np.linspace(0,1000,10000)+2

y = W*exp(2*np.pi*f*x*1J-0.5J*np.pi)

plt.plot(x,y)


# W = 4
# f = 4
# x = np.linspace(0,1,1000)+3

# y = W*exp(2*np.pi*f*x*1J-0.5J*np.pi)

#plt.plot(x,y)

def primewave(n):

  W = n
  f = n
  x = np.linspace(0,1,1000)+n-1

  y = W*np.exp(2*np.pi*f*x*1J-0.5J*np.pi)

  plt.plot(x,y);

  return y

for i in range(0,10):
  y = primewave(i)

for i in range(0,20,2):
  y = primewave(i)

"""## Fibonacci sequence makes it look 3D

### Fibonacci via machine learning
"""

# predict
def pred(x):
  return reg.predict(np.array([x]))

from sklearn.linear_model import LinearRegression

# features
fibonacci = pd.DataFrame([[1,1,2],[2,1,3],[3,2,5],[5,3,8],[8,5,13]])

# target
fibonacci.columns = [0,1,2]
fibonacci.iloc[0]
fibonacci

# train
reg = LinearRegression().fit(fibonacci[[0,1]],fibonacci[2])
reg.score(fibonacci[[0,1]],fibonacci[2])

list1 = [0,1]

for k in range(1000):
  list1.append(int(np.rint(pred([list1[k],list1[k+1]]))))
print(list1)

plt.polar(list1)

fib = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377]
for i in fib:
  y = primewave(i)

"""## Primes"""

primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]

for i in primes[0:30]:
  y = primewave(i)

m = 1000
n = np.linspace(0,m,m)
p = np.zeros(m)
f = np.zeros(m)

for i in range(0,m):
  p[i] = (primes[i])

for i in range(0,m):
  f[i] = (list1[i])

#plt.plot(n,np.log(p))
plt.plot(n,2*np.log(f))
plt.plot(n,n)


#n-2*np.log(f)

a = 10
plt.plot(n[0:a],(f[0:a]**2))
plt.plot(n[0:a],exp(n[0:a]))

plt.plot(n[0:a],np.exp(n[0:a]))

plt.plot(n,n-2*np.log(f)) # error
plt.plot(n,1.5+n*5/100)

plt.plot(n,np.exp((n-1.5+n*3.86/100)/2))
plt.plot(n,f)

m = 100
n = np.linspace(0,m,m)
p = np.zeros(m)
f = np.zeros(m)

for i in range(0,m):
  p[i] = (primes[i])

for i in range(0,m):
  f[i] = (list1[i])

#plt.plot(n,np.log(p))
plt.polar(n,2*np.log(f))
#plt.polar(n,n)

#2*np.log(f)

"""## 2D"""

def primewave2D(n):

  W = n
  f = n
  x = np.linspace(0,1,1000)+n-1

  y = W*np.exp(2*np.pi*f*x*1J-0.5J*np.pi)

  plt.plot(x+0.5,y);
  plt.plot(-y,x+0.5);

  plt.plot(x+0.5,y);
  plt.plot(-y,x+0.5);

  return y

fib = 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377

for i in fib[0:5]:
  y = primewave2D(i)

for i in fib[0:5]:
  y = primewave2D(-i)