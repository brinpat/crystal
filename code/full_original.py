# -*- coding: utf-8 -*-
"""quantum_relativity.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1n6JO99iBdwyt_Bak0mn52qz-KCcEg3c8

# Imports
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import norm, multivariate_normal
import pandas as pd
from mpl_toolkits import mplot3d
from mpl_toolkits.mplot3d import Axes3D
import pandas as pd

"""# Code functions"""

def mergedist(lamb, frequency, n):
  L = frequency*lamb
  datarange = np.arange(-0.5*L,0.5*L,0.001)
  d = norm.pdf(datarange, lamb/n, (lamb/np.pi)**2)/n
  df = pd.DataFrame(d, columns = np.arange(0,1))

  for i in range(0,n):
    d2 = norm.pdf(datarange, lamb*(2*i-n+1)/4, lamb/20)/n 
    # d2 = norm.pdf(datarange, (2*i-n+1)*lamb/n, lamb/(frequency*(n+1)))/n 
    df[i] = d2.tolist()

  return df, datarange

def electrodist(f,r1):
  distdata = 2*f*np.sum(mergedist(r1, f, 2*f)[0],axis=1) # increased the probability value while reduced the range in order to get total probability for all orbitals
  xdata = mergedist(r1, f, 2*f)[1]
  return distdata, xdata

"""# Wave function"""

# params
k = 2*np.pi
a = 1
lam = 1
L = a*lam

x = np.arange(-0.5*L,0.5*L,0.001)
phi = np.sqrt(2/L)*np.sin(k*x)
plt.plot(x,phi)
wf = 2/L*abs(phi)**2
wf_prob = sum(wf)
wf_prob

plt.plot(x,wf)

"""# Multiple distributions

## KL divergence
"""

def kl_divergence(p, q):
    return np.sum(np.where(p != 0, p * np.log(p / q), 0))

# range, mean, sd
p = norm.pdf(x, lam/4, (lam/np.pi)**2)
q = norm.pdf(x, -lam/4, (lam/np.pi)**2)
plt.plot(x,p)
plt.plot(x, q, c='red')
Dkl = kl_divergence(p, q)
Dkl

plt.plot(x,wf)
plt.plot(x,(p+q), c='r')

"""## Multiple distributions / wave function"""

# params
k = 2*np.pi
f = 2
lam = 1
L = f*lam

x = np.arange(-0.5*L,0.5*L,0.001)
phi = np.sqrt(2/L)*np.sin(k*x)
plt.plot(x,phi)
wf = 2/L*abs(phi)**2
wf_prob = sum(wf)
wf_prob

p = norm.pdf(x, lam/4, lam/(f*(4+1)))
q = norm.pdf(x, -lam/4, lam/(f*(4+1)))
r = norm.pdf(x, 3*lam/4, lam/(f*(4+1)))
s = norm.pdf(x, -3*lam/4, lam/(f*(4+1))) #(lam/np.pi)**2)
plt.plot(x,p)
plt.plot(x, q)
plt.plot(x, r)
plt.plot(x, s)
Dkl = kl_divergence(p, q)
Dkl = kl_divergence(Dkl, r)
Dkl = kl_divergence(Dkl, s)
Dkl

plt.plot(x,wf)
plt.plot(x,(p+q+r+s)/4, c='r')

"""## Multi Dist"""

datarange = x
sd = lam
n = 4

d = norm.pdf(datarange, lam/n, (lam/np.pi)**2)/n
df = pd.DataFrame(d, columns = np.arange(0,1))

for i in range(0,n):
  d2 = norm.pdf(datarange, (2*i-3)*lam/n, (lam/np.pi)**2)/n
  df[i] = d2.tolist()

df

plt.plot(x,df)

"""## Merged distribution function"""

def mergedist(datarange, mu, n):
  d = norm.pdf(datarange, mu/n, (mu/np.pi)**2)/n
  df = pd.DataFrame(d, columns = np.arange(0,1))

  for i in range(0,n):
    d2 = norm.pdf(datarange, (2*i-n+1)*mu/n, mu/(f*(n+1)))/n  #((lam/(np.pi*L))**2)*4  #(mu/np.pi)**2)/n lam/(f*(4+1)))
    df[i] = d2.tolist()

  return df

nnn = mergedist(x, lam, 10)
plt.plot(x,nnn)

nnn = mergedist(x, lam, 50)
plt.plot(x,nnn)

nnn['sum'] = nnn. sum(axis=1)
plt.plot(x,nnn['sum']) # convergence of multiple normal distributions to a singular uniform distribution

"""# 3D

## 3D version has error
"""

def mergedist3D(datarange, mu, n):
  d = norm.pdf(datarange, mu/n, (mu/np.pi)**2)/n
  df = pd.DataFrame(d, columns = np.arange(0,1))

  df3D = pd.DataFrame(d, columns = np.arange(0,1))

  for i in range(0,n):
    d2 = norm.pdf(datarange, (2*i-n+1)*mu/n, (mu/np.pi)**2)/n
    df[i] = d2.tolist()


    # Parameters to set
    mu_x = (2*i-n+1)*mu/n
    variance_x = ((mu/np.pi)**2)/n

    #Create grid and multivariate normal
    x = np.arange(-0.5*L,0.5*L,0.001)
    X, Y = np.meshgrid(x,x)
    pos = np.empty(X.shape + (2,))
    pos[:, :, 0] = X; pos[:, :, 1] = Y
    rv = multivariate_normal([mu_x, mu_x], [[variance_x, 0], [0, variance_x]])
    d3D = rv.pdf(pos)
    df3D[i] = d3D.tolist()

  return df, df3D

aaa = mergedist3D(x, lam, 4)[1]
aaa['sum'] = aaa.sum(axis=1)
aaa

aa = aaa['sum']
aa

#Make a 3D plot
x = np.arange(-0.5*L,0.5*L,0.001)
X, Y = np.meshgrid(x,x)
fig = plt.figure()
ax = fig.gca(projection='3d')
ax.plot_surface(X, Y, df,cmap='viridis',linewidth=0)
ax.set_xlabel('X axis')
ax.set_ylabel('Y axis')
ax.set_zlabel('Z axis')
plt.show()

"""## 3D plot simple"""

#Parameters to set
mu_x = 0.5
variance_x = ((lam/np.pi)**2)/n

#Create grid and multivariate normal
x = np.arange(-0.5*L,0.5*L,0.001)
X, Y = np.meshgrid(x,x)
pos = np.empty(X.shape + (2,))
pos[:, :, 0] = X; pos[:, :, 1] = Y
rv = multivariate_normal([mu_x, mu_x], [[variance_x, 0], [0, variance_x]])


#Parameters to set
mu_x2 = -0.5
variance_x2 = ((lam/np.pi)**2)/n

#Create grid and multivariate normal
x2 = np.linspace(-1,1,1000)
y2 = np.linspace(-1,1,1000)
X2, Y2 = np.meshgrid(x2,y2)
pos2 = np.empty(X2.shape + (2,))
pos2[:, :, 0] = X2; pos2[:, :, 1] = Y2
rv2 = multivariate_normal([mu_x2, mu_x2], [[variance_x2, 0], [0, variance_x2]])

rvpdf = rv.pdf(pos)+rv2.pdf(pos)
rvpdf

#Make a 3D plot
fig = plt.figure()
ax = fig.gca(projection='3d')
ax.plot_surface(X, Y, rvpdf,cmap='viridis',linewidth=0)
ax.set_xlabel('X axis')
ax.set_ylabel('Y axis')
ax.set_zlabel('Z axis')
plt.show()

"""# Electron example"""

# params
f = 2 # also number of electrons
lam = 0.73 # also atomic radius
L = f*lam

x = np.arange(-0.5*L,0.5*L,0.001)

phi = np.sqrt(2/L)*np.sin(2*np.pi*f*x/L)
plt.plot(x,phi)
wf = 2/L*abs(phi)**2
wf_prob = sum(wf)
wf_prob

def mergedist(lamb, frequency, n):
  L = frequency*lamb
  datarange = np.arange(-0.5*L,0.5*L,0.001)
  d = norm.pdf(datarange, lamb/n, (lamb/np.pi)**2)/n
  df = pd.DataFrame(d, columns = np.arange(0,1))

  for i in range(0,n):
    d2 = norm.pdf(datarange, lamb*(2*i-n+1)/4, lamb/20)/n 
    # d2 = norm.pdf(datarange, (2*i-n+1)*lamb/n, lamb/(frequency*(n+1)))/n 
    df[i] = d2.tolist()

  return df, datarange

nnn,xdata = mergedist(lam, f, 2*f)
nnn['sum'] = nnn. sum(axis=1)
#plt.plot(x,nnn['sum'])

plt.plot(x,nnn)

plt.plot(x,nnn['sum']/L)

plt.plot(x,wf)

"""# Polar"""

fig, ax = plt.subplots(subplot_kw={'projection': 'polar'})
ax.plot(4*np.pi*x/(2*L), wf)

ax.set_rlabel_position(-22.5)  # Move radial labels away from plotted line
ax.grid(True)
plt.show()

fig, ax = plt.subplots(subplot_kw={'projection': 'polar'})
ax.plot(4*np.pi*x/(2*L), nnn['sum'])

ax.set_rlabel_position(-22.5)  # Move radial labels away from plotted line
ax.grid(True)
plt.show()

"""## Polar to Cartesian plot"""

def cart2pol(x, y):
    rho = np.sqrt(x**2 + y**2)
    phi = np.arctan2(y, x)
    return(rho, phi)

def pol2cart(rho, phi):
    x = rho * np.cos(phi)
    y = rho * np.sin(phi)
    return(x, y)

theta = np.linspace(0,np.pi,100)
r = 4*np.cos(theta)
xr ,yr = pol2cart(r, theta)
plt.plot(xr, yr)

# Bell curve formula
def bellcurve(x,mu,sig):
  return np.exp((-(x-mu)**2)/(2*sig**2))/np.sqrt(2*np.pi*sig**2)

bell = 2*L*bellcurve(x,lam*(2*1-n+1)/4,lam/20)/n
plt.plot(x,bell)

"""# Atoms"""

def electrodist(f,r1):
  distdata = 2*f*np.sum(mergedist(r1, f, 2*f)[0],axis=1) # increased the probability value while reduced the range in order to get total probability for all orbitals
  xdata = mergedist(r1, f, 2*f)[1]
  return distdata, xdata

"""## H2O"""

# Water (H2O)
h_atomic_radius = 0.37 # angstrom
o_atomic_radius = 0.73 # angstrom

# Hydrogen
f=1
dist1 = 2*f*np.sum(mergedist(h_atomic_radius, f, 2*f)[0],axis=1) # increased the probability value while reduced the range in order to get total probability for all orbitals
x1 = mergedist(h_atomic_radius, f, 2*f)[1]
x1 = (2*x1*h_atomic_radius/max(x1) - o_atomic_radius - 3*h_atomic_radius)/2

# Oxygen shell 1

f=2
dist2 = 2*f*np.sum(mergedist(o_atomic_radius, f, 2*f)[0],axis=1)
x2 = mergedist(o_atomic_radius, f, 2*f)[1]
x2 = (x2 - 0.5*o_atomic_radius)/2

# Oxygen shell 2
f=6
dist3 = 2*f*np.sum(mergedist(o_atomic_radius, f, 2*f)[0],axis=1)
x3 = mergedist(o_atomic_radius, f, 2*f)[1]
x3 = (x3 - o_atomic_radius)/2

# plots
plt.plot(x1[x1>=-2.5*h_atomic_radius] , dist1[x1>=-2.5*h_atomic_radius]/max(dist1))
plt.plot(-x3[x3>=o_atomic_radius/4], dist3[x3>=o_atomic_radius/4]/max(dist1))
plt.plot(-x2[x2>=0], 2*dist2[x2>=0]/max(dist1))
plt.plot(x2[x2>=0], 2*dist2[x2>=0]/max(dist1))
plt.plot(x3[x3>=o_atomic_radius/4], dist3[x3>=o_atomic_radius/4]/max(dist1))
plt.plot(-x1[x1>=-2.5*h_atomic_radius] , dist1[x1>=-2.5*h_atomic_radius]/max(dist1))

plt.xlim(-1,1)

# Water (H2O)
h_atomic_radius = 0.37 # angstrom
o_atomic_radius = 0.73 # angstrom

# Hydrogen
dist1, x1 = electrodist(1,h_atomic_radius)
x1 = (2*x1*h_atomic_radius/max(x1) - o_atomic_radius - 3*h_atomic_radius)/2

# Oxygen shell 1
dist2, x2 = electrodist(2,o_atomic_radius)
x2 = (x2 - 0.5*o_atomic_radius)/2

# Oxygen shell 2
dist3, x3 = electrodist(6,o_atomic_radius)
x3 = (x3 - o_atomic_radius)/2

# plots
plt.plot(x1[x1>=-2.5*h_atomic_radius] , dist1[x1>=-2.5*h_atomic_radius]/max(dist1))
plt.plot(-x3[x3>=o_atomic_radius/4], dist3[x3>=o_atomic_radius/4]/max(dist1))
plt.plot(-x2[x2>=0], 2*dist2[x2>=0]/max(dist1))
plt.plot(x2[x2>=0], 2*dist2[x2>=0]/max(dist1))
plt.plot(x3[x3>=o_atomic_radius/4], dist3[x3>=o_atomic_radius/4]/max(dist1))
plt.plot(-x1[x1>=-2.5*h_atomic_radius] , dist1[x1>=-2.5*h_atomic_radius]/max(dist1))

plt.xlim(-1,1)

"""## Generalised"""

def electrodist(f,r1):
  distdata = 2*f*np.sum(mergedist(r1, f, 2*f)[0],axis=1) # increased the probability value while reduced the range in order to get total probability for all orbitals
  xdata = mergedist(r1, f, 2*f)[1]
  return distdata, xdata

"""## H2O"""

# Atom radii
atom1 = 0.37 # angstrom
atom2 = 0.73 # angstrom

## Atom 1

# Shell 1
dist1_1, x1_1 = electrodist(1,atom1) #1:2
x1_1 = (2*x1_1*atom1/max(x1_1) - atom2 - 3*atom1)/2

# Shell 2
dist2_1, x2_1 = electrodist(3,atom2) #3
x2_1 = (2*x2_1*atom1/max(x2_1) - atom2 - 3*atom1)/2


## Atom 2 (central)

# Shell 1
dist1_2, x1_2 = electrodist(2,atom2) #2
x1_2 = (x1_2 - atom2)/2

# Shell 2
dist3_2, x3_2 = electrodist(6,atom2) #6
x3_2 = (x3_2 - atom2)/2

# plots

# Atom 1
#plt.plot(x2_1[x2_1>=-2.5*atom1] , dist2_1[x2_1>=-5/2*atom1])
plt.plot(x1_1[x1_1>=-2.5*atom1] , dist1_1[x1_1>=-5/2*atom1])

# Atom 2
plt.plot(-x3_2[x3_2>=atom2/4], dist3_2[x3_2>=atom2/4])
plt.plot(-x1_2[x1_2>=-atom2/4], 2*dist1_2[x1_2>=-atom2/4])
plt.plot(x1_2[x1_2>=-atom2/4], 2*dist1_2[x1_2>=-atom2/4])
plt.plot(x3_2[x3_2>=atom2/4], dist3_2[x3_2>=atom2/4])

# Atom 1
plt.plot(-x1_1[x1_1>=-2.5*atom1] , dist1_1[x1_1>=-5/2*atom1])
#plt.plot(-x2_1[x2_1>=-2.5*atom1] , dist2_1[x2_1>=-5/2*atom1])

plt.xlim(-1.5,1.5)

"""## CO2"""

# Atom radii
atom1 = 0.73 # angstrom
atom2 = 1.5 # angstrom

## Atom 1
s1_1 = 2
s2_1 = 6

# Shell 1
dist1_1, x1_1 = electrodist(s1_1,atom1) #1:2
x1_1 = (2*x1_1*atom1/max(x1_1) - atom2 - 3*atom1)/2

# Shell 2
dist2_1, x2_1 = electrodist(s2_1,atom2) #3
x2_1 = (2*x2_1*atom1/max(x2_1) - atom2 - 3*atom1)/2


## Atom 2 (central)
s1_2 = 2
s2_2 = 4

# Shell 1
dist1_2, x1_2 = electrodist(s1_2,atom2) #2
x1_2 = atom2*(x1_2 - atom2)/2

# Shell 2
dist3_2, x3_2 = electrodist(s2_2,atom2) #6
x3_2 = atom2*(x3_2 - ((2*s2_2-4)/8)*atom2)/2 # 4:0.5 6:1 8:1.5

# plots

# Atom 1
plt.plot(x2_1[x2_1-2/s2_1>=-5/2*atom1]-0.5*atom1 , dist2_1[x2_1-2/s2_1>=-5/2*atom1])
plt.plot(x1_1[x1_1>=-5/2*atom1]-atom1 , dist1_1[x1_1>=-5/2*atom1])
plt.plot(x2_1[x2_1-2/s2_1>=-5/2*atom1]-2*atom1 , dist2_1[x2_1-2/s2_1>=-5/2*atom1])

# Atom 2
plt.plot(-x3_2[x3_2>=atom2/3], dist3_2[x3_2>=atom2/3])
plt.plot(-x1_2[x1_2>=-atom2/3], 2*dist1_2[x1_2>=-atom2/3])
plt.plot(x1_2[x1_2>=-atom2/3], 2*dist1_2[x1_2>=-atom2/3])
plt.plot(x3_2[x3_2>=atom2/3], dist3_2[x3_2>=atom2/3])

# Atom 1
plt.plot(-x2_1[x2_1-2/s2_1>=-5/2*atom1]+0.5*atom1 , dist2_1[x2_1-2/s2_1>=-5/2*atom1])
plt.plot(-x1_1[x1_1>=-5/2*atom1]+atom1 , dist1_1[x1_1>=-5/2*atom1])
plt.plot(-x2_1[x2_1-2/s2_1>=-5/2*atom1]+2*atom1 , dist2_1[x2_1-2/s2_1>=-5/2*atom1])

plt.xlim(-3,3)

"""## Adaptable"""

# Atom radii
atom1 = 0.37 # angstrom
atom2 = 0.73 # angstrom

## Atom 1
s1_1 = 1
s2_1 = 0

# Shell 1
dist1_1, x1_1 = electrodist(s1_1,atom1) #1:2
x1_1 = (2*x1_1*atom1/max(x1_1) - atom2 - 3*atom1)/2

# Shell 2
if s2_1 > 0:
  dist2_1, x2_1 = electrodist(s2_1,atom2) #3
  x2_1 = (2*x2_1*atom1/max(x2_1) - atom2 - 3*atom1)/2


## Atom 2 (central)
s1_2 = 2
s2_2 = 6

# Shell 1
dist1_2, x1_2 = electrodist(s1_2,atom2) #2
x1_2 = atom2*(x1_2 - atom2)/2

# Shell 2
dist3_2, x3_2 = electrodist(s2_2,atom2) #6
x3_2 = atom2*(x3_2 - ((2*s2_2-4)/8)*atom2)/2 # 4:0.5 6:1 8:1.5

# plots

# Atom 1
if s2_1 > 0:
  plt.plot(x2_1[x2_1-2/s2_1>=-5/2*atom1]-0.5*atom1 , dist2_1[x2_1-2/s2_1>=-5/2*atom1])
  plt.plot(x1_1[x1_1>=-5/2*atom1]-atom1 , dist1_1[x1_1>=-5/2*atom1])
  plt.plot(x2_1[x2_1-2/s2_1>=-5/2*atom1]-2*atom1 , dist2_1[x2_1-2/s2_1>=-5/2*atom1])
if s2_1 == 0:
  plt.plot(x1_1[x1_1>=-5/2*atom1] , dist1_1[x1_1>=-5/2*atom1])

# Atom 2
plt.plot(-x3_2[x3_2>=atom2/5], dist3_2[x3_2>=atom2/5])
plt.plot(-x1_2[x1_2>=-atom2/5], 2*dist1_2[x1_2>=-atom2/5])
plt.plot(x1_2[x1_2>=-atom2/5], 2*dist1_2[x1_2>=-atom2/5])
plt.plot(x3_2[x3_2>=atom2/5], dist3_2[x3_2>=atom2/5])

# Atom 1
if s2_1 > 0:
  plt.plot(-x2_1[x2_1-2/s2_1>=-5/2*atom1]+0.5*atom1 , dist2_1[x2_1-2/s2_1>=-5/2*atom1])
  plt.plot(-x1_1[x1_1>=-5/2*atom1]+atom1 , dist1_1[x1_1>=-5/2*atom1])
  plt.plot(-x2_1[x2_1-2/s2_1>=-5/2*atom1]+2*atom1 , dist2_1[x2_1-2/s2_1>=-5/2*atom1])
if s2_1 == 0:
  plt.plot(-x1_1[x1_1>=-5/2*atom1] , dist1_1[x1_1>=-5/2*atom1])

plt.xlim(-2,2)

"""# Atomic surface"""

# Atom radii
atom1 = 0.37 # angstrom
atom2 = 0.73 # angstrom

## Atom 1
s1_1 = 1
s2_1 = 0

# Shell 1
dist1_1, x1_1 = electrodist(s1_1,atom1) #1:2
x1_1 = (2*x1_1*atom1/max(x1_1) - atom2 - 3*atom1)/2

# Shell 2
if s2_1 > 0:
  dist2_1, x2_1 = electrodist(s2_1,atom2) #3
  x2_1 = (2*x2_1*atom1/max(x2_1) - atom2 - 3*atom1)/2


## Atom 2 (central)
s1_2 = 2
s2_2 = 6

# Shell 1
dist1_2, x1_2 = electrodist(s1_2,atom2) #2
x1_2 = atom2*(x1_2 - atom2)/2

# Shell 2
dist3_2, x3_2 = electrodist(s2_2,atom2) #6
x3_2 = atom2*(x3_2 - ((2*s2_2-4)/8)*atom2)/2 # 4:0.5 6:1 8:1.5

def molecule(translate):
  # Atom 1
  if s2_1 > 0:
    plt.plot(x2_1[x2_1-2/s2_1>=-5/2*atom1]-0.5*atom1+translate , dist2_1[x2_1-2/s2_1>=-5/2*atom1])
    plt.plot(x1_1[x1_1>=-5/2*atom1]-atom1+translate , dist1_1[x1_1>=-5/2*atom1])
    plt.plot(x2_1[x2_1-2/s2_1>=-5/2*atom1]-2*atom1+translate , dist2_1[x2_1-2/s2_1>=-5/2*atom1])
  if s2_1 == 0:
    plt.plot(x1_1[x1_1>=-5/2*atom1]+translate , dist1_1[x1_1>=-5/2*atom1])

  # Atom 2
  plt.plot(-x3_2[x3_2>=atom2/5]+translate, dist3_2[x3_2>=atom2/5])
  plt.plot(-x1_2[x1_2>=-atom2/5]+translate, 2*dist1_2[x1_2>=-atom2/5])
  plt.plot(x1_2[x1_2>=-atom2/(s2_2-1)]+translate, 2*dist1_2[x1_2>=-atom2/(s2_2-1)])
  plt.plot(x3_2[x3_2>=atom2/(s2_2-1)]+translate, dist3_2[x3_2>=atom2/(s2_2-1)])

  # Atom 1
  if s2_1 > 0:
    plt.plot(-x2_1[x2_1-2/s2_1>=-5/2*atom1]+0.5*atom1+translate , dist2_1[x2_1-2/s2_1>=-5/2*atom1])
    plt.plot(-x1_1[x1_1>=-5/2*atom1]+atom1+translate , dist1_1[x1_1>=-5/2*atom1])
    plt.plot(-x2_1[x2_1-2/s2_1>=-5/2*atom1]+2*atom1+translate , dist2_1[x2_1-2/s2_1>=-5/2*atom1])
  if s2_1 == 0:
    plt.plot(-x1_1[x1_1>=-5/2*atom1]+translate , dist1_1[x1_1>=-5/2*atom1])

# plots

## Molecules

tr = 2*(atom1 + atom2)
rng = 5

#tr = 40
#rng = 120
#rng = 10**4 # micrometre 
# metre of surface is 10**10

for i in range(-round(rng/tr),round(rng/tr)):
  molecule(i*tr)

plt.xlim(-rng,rng)

"""# Earth orbital electron analysis"""

# Geothermal gradient (Possible caused by free electrons)

# [percent,depth m, temp K]
Surface = [0,0,0]
Lithosphere = [410*10**3/6370*10,410*10**3,400] # Oxygen, iron, silicon
UpperMantle = [660*10**3/6370*10,660*10**3,1900] # Oxygen, rest
LowerMantle = [2900*10**3/6370*10,2900*10**3,3000] # Silicon and 100% Magnesium
OuterCore = [5150*10**3/6370*10,5150*10**3,5000] # 100% Liquid Iron
InnerCore = [6370*10**3/6370*10,6370*10**3,7000] # 100% Solid Iron

Ecore = [Surface, Lithosphere, UpperMantle, LowerMantle, OuterCore, InnerCore]
Edata = pd.DataFrame(Ecore)

x = Edata[0]/100
Depth = Edata[1]
Temp = Edata[2]
Kelvin2eV = Temp/(8.61732814974493*10**-5)

fig, ax1 = plt.subplots()

color = 'tab:red'
ax1.set_xlabel('Percent')
ax1.set_ylabel('Depth', color=color)
ax1.plot(x, Kelvin2eV, color=color)
ax1.tick_params(axis='y', labelcolor=color)

ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis

color = 'tab:blue'
ax2.set_ylabel('Temperature (k)', color=color)  # we already handled the x-label with ax1
ax2.plot(x, Temp, color=color)
ax2.tick_params(axis='y', labelcolor=color)

fig.tight_layout()  # otherwise the right y-label is slightly clipped
plt.show()

n = 175 #*10**49 # number of electrons in Earth
atom1 = 0.37

perciron = 32.1*np.array([0.333,0,0,0.333,0.333]) #32.1
eiron = [2,8,14,2]
energyiron = (eiron[0]+2*eiron[1]+3*eiron[2]+4*eiron[3])/sum(eiron)
ioniseiron = [7.9024, 16.1877,30.652,54.8,75.0]

percoxy = 30.1*np.array([0.50,0.50,0,0,0])
eoxy = [2,6]
energyoxy = (eoxy[0]+2*eoxy[1])/sum(eoxy)
ioniseoxy = [13.6181,35.1211,54.9355,77.41353,113.8990]

percsili = 15.1*np.array([1,0,0,0,0])
esili = [2,8,4]
energysili = (esili[0]+2*esili[1])/sum(esili)
ionisesili = [8.1517,16.34584,33.49302,45.14181,166.767]

percmag = 13.9*np.array([0,0,1,0,0])
emag = [2,8,2]
energymag = (emag[0]+2*emag[1]+3*emag[2])/sum(emag)
ionisemag = [7.6462,15.03527,80.1437,109.2655,141.27]

# sulfur(average of rest)
percrest = (100-perciron-percoxy-percsili-percmag)*np.array([0.2,0.22,0.2,0.2,0.18])
erest = [2,8,6]
energyrest = (erest[0]+2*erest[1]+3*erest[2])/sum(erest)
ioniserest = [10.3600,23.33788,34.79,47.222,72.5945]

Kelvin2eV 




energy_100particles = perciron*energyiron+percoxy*energyoxy+percsili*energysili+percmag*energymag+percrest*energyrest

av_eV = energy_100particles/100
av_eV # per layer

Kelvin2eV # suggests elements below and including Upper Mantle completely ionised as 4E6 eV is much larger than any ionisation energies combined

# 410*10**3 # proportion of area with orbital electrons

# VE = 1.0832*10**21  # Volume of Earth

# Vseg1 = (4/3)*np.pi*(5100*10**3)**3  # V = 4/3 pi r**3
# perc_inc = Vseg1/VE

# Vseg2 = (4/3)*np.pi*(2900*10**3)**3  # V = 4/3 pi r**3
# Vseg_outc = Vseg2 - Vseg1
# perc_outc = Vseg_outc/VE

# Vseg3 = (4/3)*np.pi*(660*10**3)**3  # V = 4/3 pi r**3
# Vseg_lowm = Vseg3 - (Vseg1+Vseg2)
# perc_lowm = Vseg_lowm/VE

# Vseg4 = (4/3)*np.pi*(410*10**3)**3  # V = 4/3 pi r**3
# Vseg_upm = Vseg4 - (Vseg1+Vseg2+Vseg3)
# perc_upm = Vseg_upm/VE

# Vseg5 = (4/3)*np.pi*(6378*10**3)**3  # V = 4/3 pi r**3
# Vseg_lith = Vseg5 - (Vseg1+Vseg2+Vseg3+Vseg4)
# perc_lith = Vseg_lith/VE

perc_lith = 0.01
perc_mantle = 0.84
perc_core = 0.15

Edist, Ex = electrodist(n,atom1)

EdistNorm = Edist/max(Edist)
#plt.polar(Ex,av_eV*EdistNorm) 

energyE = sum(av_eV[0]*EdistNorm)*(1.60217*10**-19) # orbital electron energy in Earth

me = (n*10**49)*9.1*10**-31 # mass of all electrons
me_lith = (n*10**49)*9.1*10**-31 # mass of all electrons 

f=(1.60217*10**-19)/(6.63*10**-34) # freq of electron wave f= E/h
T=1/f
m2_s = T*energyE/me_lith # a = (E x T)/mass (change to energy and mass of orbital electrons)

a = m2_s*n*10**49
a

n = 175*10**49 # total number of electrons
numorbital = 1.2997*10**47
numfree = n - numorbital # 1.75E51

energyE = (n / numorbital)*(1.60217*10**-19) # ratio of total electron energy to orbital electron energy in Earth
moe = (9.1*10**-31) # mass of one orbital electron

f=(1.60217*10**-19)/(6.63*10**-34) # freq of electron wave f= E/h
T=1/f
m2_s_2 = energyE*T/moe # a = (E x T)/mass (change to energy and mass of orbital electrons) ratio of 

a = m2_s_2
a

"""## Testing electograv equations"""

# Earth
Temp = 288  # kelvin
Pressure = 101325  # pascals
mass = 5.972*10**24
Volume = 1.0832*10**21

Epvt = Pressure/Temp


n = 0.49*mass/(1.672619*10**-27) # total number of electrons: 175*10**49
nEarth = n
numorbital = 1.2997*10**47
numfree = n - numorbital # 1.74987E51

energyE = (n / numorbital)*(1.60217*10**-19) # ratio of total electron energy to orbital electron energy in Earth
moe = (9.1*10**-31) # mass of one orbital electron

f=(1.60217*10**-19)/(6.63*10**-34) # freq of electron wave f=E/h
T=1/f
m2_s_2 = energyE*T/moe # a = (E x T)/mass (change to energy and mass of orbital electrons) ratio of 

a = m2_s_2
a

# Mercury
Temp = 415  # kelvin
Pressure = 101325  # pascals
mass = 3.285*10**23
Volume = 6.08*10**19

Vpvt = Pressure/Temp

n = 0.49*mass/(1.672619*10**-27) # total number of electrons
nVenus = n

pvt_ratio = np.sqrt(1/((nEarth/nVenus)*(Vpvt/Epvt)))  # gas law (Gay-Lussac's law as volume remains the same)
print(pvt_ratio)

numorbital = 1.2997*10**47
numfree = n - numorbital # 1.74987E51

energyE = (n / numorbital)*(1.60217*10**-19) # ratio of total electron energy to orbital electron energy in Earth # (0.1458)*
moe = (9.1*10**-31) # mass of one orbital electron

f=(1.60217*10**-19)/(6.63*10**-34) # freq of electron wave f=E/h
T=1/f
m2_s_2 = energyE*T/moe # a = (E x T)/mass (change to energy and mass of orbital electrons) ratio of 

a = m2_s_2
a

# Venus
Temp = 737  # kelvin
Pressure = 93*101325  # pascals
mass = 4.867*10**24
Volume = 9.2843*10**20

Vpvt = Pressure/Temp

n = 0.49*mass/(1.672619*10**-27) # total number of electrons
nVenus = n

pvt_ratio = np.sqrt(1/((nEarth/nVenus)*(Vpvt/Epvt)))  # gas law (Gay-Lussac's law as volume remains the same)
print(pvt_ratio)

numorbital = 1.2997*10**47
numfree = n - numorbital # 1.74987E51

energyE = (n / numorbital)*(1.60217*10**-19) # ratio of total electron energy to orbital electron energy in Earth # (1.10977)*
moe = (9.1*10**-31) # mass of one orbital electron

f=(1.60217*10**-19)/(6.63*10**-34) # freq of electron wave f=E/h
T=1/f
m2_s_2 = energyE*T/moe # a = (E x T)/mass (change to energy and mass of orbital electrons) ratio of 

a = m2_s_2
a

# Mars
Temp = 210  # kelvin
Pressure = 610  # pascals
mass = 6.39*10**23
Volume = 1.6318*10**20

Mpvt = Pressure/Temp

n = 0.49*mass/(1.672619*10**-27) # total number of electrons
nMars = n

pvt_ratio = np.sqrt(1/((nEarth/nMars)*(Mpvt/Epvt)))  # gas law (Gay-Lussac's law as volume remains the same)
print(pvt_ratio)

numorbital = 1.2997*10**47
numfree = n - numorbital # 1.74987E51

energyE = (n / numorbital)*(1.60217*10**-19) # ratio of total electron energy to orbital electron energy in Earth # (3.545937)*
moe = (9.1*10**-31) # mass of one orbital electron

f=(1.60217*10**-19)/(6.63*10**-34) # freq of electron wave f=E/h
T=1/f
m2_s_2 = energyE*T/moe # a = (E x T)/mass (change to energy and mass of orbital electrons) ratio of 

a = m2_s_2
a

# Jupiter
Temp = 165  # kelvin
Pressure = 400000  # pascals
mass = 1.898*10**27
Volume = 1.43128*10**24

Jpvt = Pressure/Temp

n = 0.49*(mass)/(1.672619*10**-27) # total number of electrons
nJup = n

pvt_ratio = np.sqrt(1/(((nEarth/nJup)*(Jpvt/Epvt))))  # gas law (Gay-Lussac's law as volume remains the same)
print(pvt_ratio)

numorbital = 1.2997*10**47
numfree = n - numorbital # 1.74987E51

energyE = (n / numorbital)*(1.60217*10**-19) # ratio of total electron energy to orbital electron energy in Earth # (0.0079534)*
moe = (9.1*10**-31) # mass of one orbital electron

f=(1.60217*10**-19)/(6.63*10**-34) # freq of electron wave f=E/h
T=1/f
m2_s_2 = energyE*T/moe # a = (E x T)/mass (change to energy and mass of orbital electrons) ratio of 

a = m2_s_2
a

# Saturn
Temp = 134  # kelvin
Pressure = 140000  # pascals
mass = 5.683*10**26
Volume = 8.2713*10**23

Jpvt = Pressure/Temp

n = 0.49*(mass)/(1.672619*10**-27) # total number of electrons
nJup = n

pvt_ratio = np.sqrt(1/(((nEarth/nJup)*(Jpvt/Epvt))))  # gas law (Gay-Lussac's law as volume remains the same)
print(pvt_ratio)

numorbital = 1.2997*10**47
numfree = n - numorbital # 1.74987E51

energyE = (n / numorbital)*(1.60217*10**-19) # ratio of total electron energy to orbital electron energy in Earth # (0.0111865)*
moe = (9.1*10**-31) # mass of one orbital electron

f=(1.60217*10**-19)/(6.63*10**-34) # freq of electron wave f=E/h
T=1/f
m2_s_2 = energyE*T/moe # a = (E x T)/mass (change to energy and mass of orbital electrons) ratio of 

a = m2_s_2
a

# Uranus
Temp = 750  # kelvin
Pressure = 101325  # pascals
mass = 8.681*10**25
Volume = 6.833*10**22

Upvt = Pressure/Temp

n = 0.49*(mass)/(1.672619*10**-27) # total number of electrons
nUra = n

pvt_ratio = np.sqrt(1/(((nEarth/nUra)*(Upvt/Epvt))))  # gas law (Gay-Lussac's law as volume remains the same)
print(pvt_ratio)

numorbital = 1.2997*10**47
numfree = n - numorbital # 1.74987E51

energyE = (n / numorbital)*(1.60217*10**-19) # ratio of total electron energy to orbital electron energy in Earth # (0.0622)*
moe = (9.1*10**-31) # mass of one orbital electron

f=(1.60217*10**-19)/(6.63*10**-34) # freq of electron wave f=E/h
T=1/f
m2_s_2 = energyE*T/moe # a = (E x T)/mass (change to energy and mass of orbital electrons) ratio of 

a = m2_s_2
a

# Sun
Temp = 5778  # kelvin
Pressure = 340000000000*101325  # pascals
mass = 1.989*10**30
Volume = 1.4*10**27

Upvt = Pressure/Temp

n = 0.49*(mass)/(1.672619*10**-27) # total number of electrons
nUra = n

pvt_ratio = np.sqrt(1/(((nEarth/nUra)*(Upvt/Epvt))))  # gas law (Gay-Lussac's law as volume remains the same)
print(pvt_ratio)

numorbital = 1.2997*10**47
numfree = n - numorbital # 1.74987E51

energyE = (n / numorbital)*(1.60217*10**-19) # ratio of total electron energy to orbital electron energy in Earth # (8.3885657E-5)*
moe = (9.1*10**-31) # mass of one orbital electron

f=(1.60217*10**-19)/(6.63*10**-34) # freq of electron wave f=E/h
T=1/f
m2_s_2 = energyE*T/moe # a = (E x T)/mass (change to energy and mass of orbital electrons) ratio of 

a = m2_s_2
a

"""## Observing the error"""

orbital_free_ratio_error = np.array([0.1458,1.10977,3.545937,0.0079534,0.0111865,0.0622]) # Merc, Venus, Mars, Jupiter, Saturn, Uranus
error2 = np.array([-3.160535,-0.877375,-2.67163,3092.12,922.826,133.69]) # Merc, Venus, Mars, Jupiter, Saturn, Uranus

# Earth
ETemp = 288  # kelvin
EPressure = 101325  # pascals
EVolume = 1.0832*10**21


Volume = np.array([6.08*10**19,9.2843*10**20,1.6318*10**20,1.43128*10**24,8.2713*10**23,6.833*10**22])
Pressure = np.array([101325,93*101325,610,400000,140000,101325])  # pascals
Temp = np.array([415,737,210,165,134,750])  # kelvin

# Relative

RVolume = np.array([6.08*10**19,9.2843*10**20,1.6318*10**20,1.43128*10**24,8.2713*10**23,6.833*10**22])-EVolume
RPressure = np.array([101325,93*101325,610,400000,140000,101325])-EPressure  # pascals
RTemp = np.array([415,737,210,165,134,750])-ETemp  # kelvin

#plt.scatter(error2,RPressure)

#plt.scatter(error2,RTemp)

#plt.scatter(error2,RVolume)

x = (3*RVolume/(4*np.pi))**(3)*RPressure**(0)*RTemp**(0)
plt.scatter(x,error2)


# Calculate the polynomial
coefficients = np.polyfit(x,error2, 2)
poly = np.poly1d(coefficients)

# Calculate new x and y values
new_x = np.linspace(min(x), max(x))
y = coefficients[2]+coefficients[1]*new_x+coefficients[0]*new_x**2

plt.plot(new_x,y)
print(coefficients)

plt.xlabel('Volume')
plt.ylabel('Error')

# with Sun added

orbital_free_ratio_error = np.array([0.1458,1.10977,3.545937,0.0079534,0.0111865,0.0622,8.3885657E-5]) # Merc, Venus, Mars, Jupiter, Saturn, Uranus, Sun
error2 = np.array([-3.160535,-0.877375,-2.67163,3092.12,922.826,133.69,3266077]) # Merc, Venus, Mars, Jupiter, Saturn, Uranus, Sun

Volume = np.array([6.08*10**19,9.2843*10**20,1.6318*10**20,1.43128*10**24,8.2713*10**23,6.833*10**22,1.4*10**27]) # Merc, Venus, Mars, Jupiter, Saturn, Uranus, Sun
Pressure = np.array([101325,93*101325,610,400000,140000,101325,340000000000*101325])  # pascals
Temp = np.array([415,737,210,165,134,750,5778])  # kelvin

#plt.scatter(Pressure,orbital_free_ratio_error)
#plt.scatter(Temp,orbital_free_ratio_error)
#plt.scatter(Volume,orbital_free_ratio_error)
#plt.scatter(Volume,orbital_free_ratio_error)

#formula = Volume**(1/6)/(Pressure**(2/6)*Temp**(7/10)*orbital_free_ratio_error**(6/4))
#formula = Volume**(1/2)/(Pressure**(0)*Temp**(0)*orbital_free_ratio_error**(6/4))
formula = Volume

plt.scatter(error2, formula)

x = np.linspace(0,4E6,100000)
y = x

ms = (max(formula)-min(formula))/(max(error2)-min(error2))

plt.plot(x,ms*y)
plt.xlabel('Error')
plt.ylabel('Formula')



print(max(formula))
print(max(error2))
print(ms)

orbital_free_ratio_error = np.array([0.1458,1.10977,3.545937,0.0079534,0.0111865,0.0622]) # Merc, Venus, Mars, Jupiter, Saturn, Uranus
error2 = np.array([-3.160535,-0.877375,-2.67163,3092.12,922.826,133.69]) # Merc, Venus, Mars, Jupiter, Saturn, Uranus

Volume = np.array([6.08*10**19,9.2843*10**20,1.6318*10**20,1.43128*10**24,8.2713*10**23,6.833*10**22]) # Merc, Venus, Mars, Jupiter, Saturn, Uranus
Pressure = np.array([101325,93*101325,610,400000,140000,101325])  # pascals
Temp = np.array([415,737,210,165,134,750])  # kelvin

#plt.scatter(Pressure,orbital_free_ratio_error)
#plt.scatter(Temp,orbital_free_ratio_error)
#plt.scatter(Volume,orbital_free_ratio_error)
#plt.scatter(Volume,orbital_free_ratio_error)

#formula = Volume**(1/6)/(Pressure**(2/6)*Temp**(7/10)*orbital_free_ratio_error**(6/4))
#formula = Volume**(1/2)/(Pressure**(0)*Temp**(0)*orbital_free_ratio_error**(6/4))
formula = Volume

plt.scatter(error2, formula)

x = np.linspace(0,3400,3400)
y = x

m = (max(formula)-min(formula))/(max(error2)-min(error2))

plt.plot(x,m*y)

plt.plot(x,ms*y)

plt.xlabel('Error')
plt.ylabel('Volume')

print(max(formula))
print(max(error2))
print(m)

# So volume / ms = error

def err_removal(Volume):
   orbital_ratio_error = Volume/ms # ms = 4.623875554465697e+20
   return orbital_ratio_error

Volume = np.array([6.08*10**19,9.2843*10**20,1.6318*10**20,1.43128*10**24,8.2713*10**23,6.833*10**22])

print(orbital_free_ratio_error) # Merc, Venus, Mars, Jupiter, Saturn, Uranus
err_removal(Volume)

"""## (Not used) Error removal"""

# Applying machine learning
iterate = 10

# Stored
Volume = np.array([6.08*10**19,9.2843*10**20,1.6318*10**20,1.43128*10**24,8.2713*10**23,6.833*10**22])
Pressure = np.array([101325,93*101325,610,400000,140000,101325])  # pascals
Temp = np.array([415,737,210,165,134,750])  # kelvin

# Initialise
const_stored = np.array([100,1,1,1])
stored_loss = -1E30*np.ones(len(Volume))
plotloss = 1E30*np.ones([iterate,len(Volume)])
plotsumloss = []
# Ratio error
orbital_free_ratio_error = np.array([0.1458,1.10977,3.545937,0.0079534,0.0111865,0.0622]) # Merc, Venus, Mars, Jupiter, Saturn, Uranus



# Machine learning to remove error
for i in range(iterate):

  # Formula to remove error
  formula = const_stored[0]*Volume**(const_stored[1])/(Pressure**(const_stored[2])*Temp**(const_stored[3]))

  loss = -abs(orbital_free_ratio_error - formula) # trying to make this equal to 0

  print(np.round(stored_loss,2))
  #print(loss)

  for j in range(len(Volume)):

    if loss[j]>stored_loss[j]:
      stored_loss[j] = loss[j] # loss has improved

    plotloss[i,j] = stored_loss[j]


# Back propagation

  for n in range(-iterate):
    
    if sum(loss)>sum(stored_loss):
      const_stored = np.random.random(4)
  

  plotsumloss.append(sum(stored_loss))

plt.plot(range(iterate),plotsumloss)

plt.plot(range(iterate)[0:20],plotloss[0:20]);

print(const_stored[0],const_stored[1],const_stored[2],const_stored[3])

def err_formula(Volume,Pressure,Temperature):
  return const_stored[0]*Volume**(const_stored[1])/(Pressure**(const_stored[2])*Temperature**(const_stored[3]))

# Test error removal

# Mercury
Temp = 415  # kelvin
Pressure = 101325  # pascals
Volume = 6.08*10**19

# # Uranus
# Temp = 750  # kelvin
# Pressure = 101325  # pascals
# Volume = 6.833*10**22

# Jupiter
Temp = 165  # kelvin
Pressure = 400000  # pascals
Volume = 1.43128*10**24

print(orbital_free_ratio_error) # Merc, Venus, Mars, Jupiter, Saturn, Uranus
err_formula(Volume,Pressure,Temp)

"""## Testing electograv equations with error removal"""

def err_removal(Volume):
   return Volume/ms # ms = 4.623875554465697e+20

# Earth
Temp = 288  # kelvin
Pressure = 101325  # pascals
mass = 5.972*10**24
Volume = 1.0832*10**21

Epvt = Pressure/Temp


Kel2eV = 8.61732814974493E-05
Temp_eV = 288*Kel2eV

n = 0.49*mass/(1.672619*10**-27) # total number of electrons: 175*10**49
nEarth = n
numorbital = 1.2997*10**47
numfree = n - numorbital # 1.74987E51

energyE = (n / (n-numfree))*(1.60217*10**-19) # ratio of total electron energy to orbital electron energy in Earth
moe = (9.1*10**-31) # mass of one orbital electron

f=(1.60217*10**-19)/(6.63*10**-34) # freq of electron wave f=E/h
T=1/f
m2_s_2 = energyE*T/moe # a = (E x T)/mass (change to energy and mass of orbital electrons) ratio of 

a = m2_s_2
a

# Mercury
Temp = 415  # kelvin
Pressure = 101325  # pascals
mass = 3.285*10**23
Volume = 6.08*10**19

Vpvt = Pressure/Temp

n = 0.49*mass/(1.672619*10**-27) # total number of electrons
nVenus = n

pvt_ratio = np.sqrt(1/((nEarth/nVenus)*(Vpvt/Epvt)))  # gas law (Gay-Lussac's law as volume remains the same)
print(pvt_ratio)

numorbital = 1.2997*10**47
numfree = n - numorbital # 1.74987E51

energyE = (n / numorbital)*(1.60217*10**-19) # ratio of total electron energy to orbital electron energy in Earth # (0.1458)*
moe = (9.1*10**-31) # mass of one orbital electron

f=(1.60217*10**-19)/(6.63*10**-34) # freq of electron wave f=E/h
T=1/f
m2_s_2 = energyE*T/moe # a = (E x T)/mass (change to energy and mass of orbital electrons) ratio of 

a = m2_s_2 
abs(a-(err_removal(Volume)))

# Venus
Temp = 737  # kelvin
Pressure = 93*101325  # pascals
mass = 4.867*10**24
Volume = 9.2843*10**20

Vpvt = Pressure/Temp

n = 0.49*mass/(1.672619*10**-27) # total number of electrons
nVenus = n

pvt_ratio = np.sqrt(1/((nEarth/nVenus)*(Vpvt/Epvt)))  # gas law (Gay-Lussac's law as volume remains the same)
print(pvt_ratio)

numorbital = 1.2997*10**47
numfree = n - numorbital # 1.74987E51

energyE = (n / numorbital)*(1.60217*10**-19) # ratio of total electron energy to orbital electron energy in Earth # (1.10977)*
moe = (9.1*10**-31) # mass of one orbital electron

f=(1.60217*10**-19)/(6.63*10**-34) # freq of electron wave f=E/h
T=1/f
m2_s_2 = energyE*T/moe # a = (E x T)/mass (change to energy and mass of orbital electrons) ratio of 

a = m2_s_2
abs(a-(err_removal(Volume)))

# Mars
Temp = 210  # kelvin
Pressure = 610  # pascals
mass = 6.39*10**23
Volume = 1.6318*10**20

Mpvt = Pressure/Temp

n = 0.49*mass/(1.672619*10**-27) # total number of electrons
nMars = n

pvt_ratio = np.sqrt(1/((nEarth/nMars)*(Mpvt/Epvt)))  # gas law (Gay-Lussac's law as volume remains the same)
print(pvt_ratio)

numorbital = 1.2997*10**47
numfree = n - numorbital # 1.74987E51

energyE = (n / numorbital)*(1.60217*10**-19) # ratio of total electron energy to orbital electron energy in Earth # (3.545937)*
moe = (9.1*10**-31) # mass of one orbital electron

f=(1.60217*10**-19)/(6.63*10**-34) # freq of electron wave f=E/h
T=1/f
m2_s_2 = energyE*T/moe # a = (E x T)/mass (change to energy and mass of orbital electrons) ratio of 

a = m2_s_2
abs(a-(err_removal(Volume)))

# Jupiter
Temp = 165  # kelvin
Pressure = 400000  # pascals
mass = 1.898*10**27
Volume = 1.43128*10**24

Jpvt = Pressure/Temp

n = 0.49*(mass)/(1.672619*10**-27) # total number of electrons
nJup = n

pvt_ratio = np.sqrt(1/(((nEarth/nJup)*(Jpvt/Epvt))))  # gas law (Gay-Lussac's law as volume remains the same)
print(pvt_ratio)

numorbital = 1.2997*10**47
numfree = n - numorbital # 1.74987E51

energyE = (n / numorbital)*(1.60217*10**-19) # ratio of total electron energy to orbital electron energy in Earth # (0.0079534)*
moe = (9.1*10**-31) # mass of one orbital electron

f=(1.60217*10**-19)/(6.63*10**-34) # freq of electron wave f=E/h
T=1/f
m2_s_2 = energyE*T/moe # a = (E x T)/mass (change to energy and mass of orbital electrons) ratio of 

a = m2_s_2
abs(a-(err_removal(Volume)))

# Saturn
Temp = 134  # kelvin
Pressure = 140000  # pascals
mass = 5.683*10**26
Volume = 8.2713*10**23

Jpvt = Pressure/Temp

n = 0.49*(mass)/(1.672619*10**-27) # total number of electrons
nJup = n

pvt_ratio = np.sqrt(1/(((nEarth/nJup)*(Jpvt/Epvt))))  # gas law (Gay-Lussac's law as volume remains the same)
print(pvt_ratio)

numorbital = 1.2997*10**47
numfree = n - numorbital # 1.74987E51

energyE = (n / numorbital)*(1.60217*10**-19) # ratio of total electron energy to orbital electron energy in Earth # (0.0111865)*
moe = (9.1*10**-31) # mass of one orbital electron

f=(1.60217*10**-19)/(6.63*10**-34) # freq of electron wave f=E/h
T=1/f
m2_s_2 = energyE*T/moe # a = (E x T)/mass (change to energy and mass of orbital electrons) ratio of 

a = m2_s_2
a

# Uranus
Temp = 750  # kelvin
Pressure = 101325  # pascals
mass = 8.681*10**25
Volume = 6.833*10**22

Upvt = Pressure/Temp

n = 0.49*(mass)/(1.672619*10**-27) # total number of electrons
nUra = n

pvt_ratio = np.sqrt(1/(((nEarth/nUra)*(Upvt/Epvt))))  # gas law (Gay-Lussac's law as volume remains the same)
print(pvt_ratio)

numorbital = 1.2997*10**47
numfree = n - numorbital # 1.74987E51

energyE = (n / numorbital)*(1.60217*10**-19) # ratio of total electron energy to orbital electron energy in Earth # (0.0622)*
moe = (9.1*10**-31) # mass of one orbital electron

f=(1.60217*10**-19)/(6.63*10**-34) # freq of electron wave f=E/h
T=1/f
m2_s_2 = energyE*T/moe # a = (E x T)/mass (change to energy and mass of orbital electrons) ratio of 

a = m2_s_2
(err_removal(Volume))-a

# Sun
Temp = 5778  # kelvin
Pressure = 340000000000*101325  # pascals
mass = 1.989*10**30
Volume = 1.4*10**27

Upvt = Pressure/Temp

n = 0.49*(mass)/(1.672619*10**-27) # total number of electrons
nUra = n

pvt_ratio = np.sqrt(1/(((nEarth/nUra)*(Upvt/Epvt))))  # gas law (Gay-Lussac's law as volume remains the same)
print(pvt_ratio)

numorbital = 1.2997*10**47
numfree = n - numorbital # 1.74987E51

energyE = (n / numorbital)*(1.60217*10**-19) # ratio of total electron energy to orbital electron energy in Earth # (0.0622)*
moe = (9.1*10**-31) # mass of one orbital electron

f=(1.60217*10**-19)/(6.63*10**-34) # freq of electron wave f=E/h
T=1/f
m2_s_2 = energyE*T/moe # a = (E x T)/mass (change to energy and mass of orbital electrons) ratio of 

a = m2_s_2

a-(err_removal(Volume))

"""## Reversed calculations"""

# Reversed

f=(1.60217*10**-19)/(6.63*10**-34) # freq of electron wave f= E/h
T=1/f
n = 175 #*10**49
g = 9.81
m2_s_rev = g/(n*10**49) # acceleration / no. electrons in Earth
predicted_orbital_e_mass_perE = T/m2_s_rev # total orbital mass = E*T*ne/a

n_orbital_perE = predicted_orbital_e_mass_perE/(9.1*10**-31) # number of orbital electrons = E*T*n/(a*me)
n_orbital_perE

n_orbital_perE = T*1.75*10**51/(g*9.1*10**-31) # shortened (per Joule)
n_orbital_perEv = n_orbital_perE*(1.60217*10**-19) # (per eV)
n_orbital_perEv

# One electron gravity contribution estimate

energy1 = 1.60217*10**-19
me1 = 9.1*10**-31

a = energy1*T*1/me1
a

n_orbital_perEv*a # combined acceleration for electrons of 1eV

Eo = n_orbital_perEv*a/9.81 # total energy of 1eV orbital electrons
Eo

numo = Eo*T/(a*me1*n*10**49)          # Eo*T/(a*me1*n)
numo # number of orbital electrons in Earth: 3.44*10**10

numo = Eo/(13.6*energy1*n*10**49) # simplified (total energy of 1J orbital electrons)/(number of orbital electrons)
numo

Eo1 = Eo/numo
Eo1
sum(EdistNorm)

"""# Gravitational acceleration formula using orbital-free electron ratio"""

def orbital_free_ratio(gravity):
  return gravity*(9.1E-31)/(6.63E-34)

def orbital_free_ratio(gravity):
  return gravity*(9.1E-31)/((6.63E-34)*(1.6E-19))

def total_electrons(mass):
  return 0.49*mass/(1.672619*10**-27) # total number of electrons

"""## Feature Extraction

"""

# Planetary data

planet = np.array(['Merc 3.7', 'Venus 8.8', 'Earth 9.8', 'Mars 3.7', 'Jupiter 24.7', 'Saturn 10.5', 'Uranus 9.0','Neptune 11.7','Pluto 0.49', 'Sun 293.0'])
Volume = np.array([6.08*10**19,9.2843*10**20,1.0832*10**21,1.6318*10**20,1.43128*10**24,8.2713*10**23,6.833*10**22,6.254E22,6.4E18,1.4*10**27])
Pressure = np.array([101325,93*101325,101325,610,400000,140000,101325,1000E5,0.022,340000000000*101325])  # pascals
Temp = np.array([415,737,288,210,165,134,76,72,44,5778])  # kelvin
Core_Pressure = np.array([5,700,330,40,3000,4620,800,10,1.34,2.6E7])  # gigapascals (Venus unknown)
Sun_distance = np.array([0.39,0.72,1,1.52,5.2,9.54,19.2,30.06,39,0.001]) # au

Grav = np.array([3.7,8.8,9.8,3.7,24.7,10.5,9.0,11.7,0.49,293.0])  # m2s_2
mass = np.array([0.330,4.87,5.97,0.642,1898,568,86.8,1.024E2,0.01303,1989000])*10**24  # kg

orb2free_ratio = orbital_free_ratio(Grav) # = (e_orb + e_free) / e_orb  (or = eT / e_orb)
eT = total_electrons(mass)

# Note that orb2free_ratio = eT / e_orb
# and so e_orb = eT / orb2free_ratio

e_orb = eT / orb2free_ratio

e_free = eT - e_orb

print(e_orb)
print('')
print(e_free)

# Merc, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune, Pluto, Sun

"""## PCA analysis (Categorise planets)

### Feature extraction
"""

from mpl_toolkits.mplot3d import Axes3D
from sklearn import decomposition

data = [planet,Volume,Pressure,Temp,Core_Pressure, Sun_distance, Grav, mass, e_orb, e_free, eT, orb2free_ratio]
header = ['planet','Volume','Pressure','Temp','Core_Pressure', 'Sun_distance', 'Grav', 'mass', 'e_orb', 'e_free', 'eT', 'orb2free_ratio']
df = pd.DataFrame(np.transpose(data), columns = header)
df = df.set_index('planet')
df

mean = df.mean()
sd = df.std()

df_norm = ((df-mean)/sd).astype(float) # Normalise
df_norm
df_norm = df_norm.drop('Sun 293.0')
df_norm = df_norm.drop(header[1:3], axis = 1)
df_norm = df_norm.drop(header[4:8], axis = 1)
df_norm = df_norm.drop(header[9:12], axis = 1)
df_norm

"""### PCA analysis"""

cov_data = np.cov(df_norm.T) # covariance matrix

img = plt.matshow(cov_data, cmap=plt.cm.rainbow)
plt.colorbar(img, ticks = [-1, 0, 1], fraction=0.045)
for x in range(cov_data.shape[0]):
    for y in range(cov_data.shape[1]):
        plt.text(x, y, "%0.2f" % cov_data[x,y], size=12, color='black', ha="center", va="center")
        
plt.show() # strong correlation between feature 4 and all other features

eigenvalues,eigenvectors = np.linalg.eig(cov_data)
print(eigenvalues)
print('')
#print(eigenvectors)

# PCA

pca = decomposition.PCA()
pca = pca.fit(df_norm)
plt.bar(np.arange(1,1+len(df_norm.count())), pca.explained_variance_ratio_)
plt.xticks(np.arange(1,1+len(df_norm.count())))  # Set label locations.
plt.xlabel("Component number")
plt.ylabel("Proportion of Variance")
plt.title("Scree Plot")

pca = decomposition.PCA(n_components = 2)
pca = pca.fit(df_norm)
df_transformed = pca.transform(df_norm)

print(df_transformed)

"""### PCA plot"""

# With simply temperature and number of orbital electrons
# we can work out the type of planet

for i, txt in enumerate(planet[0:len(df_norm)]):
    plt.scatter(df_transformed[i,0],df_transformed[i,1], label = planet[i])
    plt.annotate(txt, (df_transformed[i,0],df_transformed[i,1]))

plt.grid(color='k', linestyle='-', linewidth=0.1)

"""## Orbital vs free"""

n = 4 # up to 10
z = (e_orb)[0:n]
y = (e_free)[0:n]

plt.scatter(z, y)

for i, txt in enumerate(planet[0:n]):
    plt.annotate(txt, (z[i], y[i]))

n = 4 # up to 10
z = np.append((e_orb/Sun_distance)[0:n],(e_orb/Sun_distance)[6:9])
y = np.append((e_free/Sun_distance)[0:n],(e_free/Sun_distance)[6:9])

plt.scatter(z, y)

for i, txt in enumerate(np.append(planet[0:n],planet[6:9])):
    plt.annotate(txt, (z[i], y[i]))

n = 9

z = e_free[0:n]
y = np.log(Volume[0:n])

plt.scatter(e_orb[0:n], y,label='Orbital')
plt.scatter(z,y,label='Free');

for i, txt in enumerate(planet[0:n]):
    plt.annotate(txt, (z[i], y[i]))

plt.legend()

n = 9

z = e_free[0:n]
y = np.log(Volume[0:n]*Sun_distance[0:n])

plt.scatter(e_orb[0:n], y,label='Orbital')
plt.scatter(z,y,label='Free');

for i, txt in enumerate(planet[0:n]):
    plt.annotate(txt, (z[i], y[i]))

plt.legend()

n = 9

z = e_free[0:n]
y = np.log(Core_Pressure[0:n])

plt.scatter(e_orb[0:n], y,label='Orbital')
plt.scatter(z,y,label='Free');

for i, txt in enumerate(planet[0:n]):
    plt.annotate(txt, (z[i], y[i]))

plt.legend()

n = 9

z = e_free[0:n]
y = np.log(Core_Pressure[0:n]*Sun_distance[0:n])

plt.scatter(e_orb[0:n], y,label='Orbital')
plt.scatter(z,y,label='Free');

for i, txt in enumerate(planet[0:n]):
    plt.annotate(txt, (z[i], y[i]))

plt.legend()

n = 9

z = e_free[0:n]
y = np.log(Pressure[0:n])

plt.scatter(e_orb[0:n], y,label='Orbital')
plt.scatter(z,y,label='Free');

for i, txt in enumerate(planet[0:n]):
    plt.annotate(txt, (z[i], y[i]))

plt.legend()

n = 9

z = e_free[0:n]
y = np.log(Pressure[0:n]*Sun_distance[0:n])

plt.scatter(e_orb[0:n], y,label='Orbital')
plt.scatter(z,y,label='Free');

for i, txt in enumerate(planet[0:n]):
    plt.annotate(txt, (z[i], y[i]))

plt.legend()

n = 9

z = e_free[0:n]
y = Temp[0:n]

plt.scatter(e_orb[0:n], y,label='Orbital')
plt.scatter(z,y,label='Free');

for i, txt in enumerate(planet[0:n]):
    plt.annotate(txt, (z[i], y[i]))

plt.legend()

n = 9

z = e_free[0:n]
y = Temp[0:n]*Sun_distance[0:n]

plt.scatter(e_orb[0:n], y,label='Orbital')
plt.scatter(z,y,label='Free');

for i, txt in enumerate(planet[0:n]):
    plt.annotate(txt, (z[i], y[i]))

plt.legend()

n = 9

z = e_free[0:n]
y = np.log((Volume/Core_Pressure))[0:n]

plt.scatter(e_orb[0:n], y,label='Orbital');
plt.scatter(z,y,label='Free');

for i, txt in enumerate(planet[0:n]):
    plt.annotate(txt, (z[i], y[i]))

plt.legend()

n = 9

z = e_orb[0:n]
y = np.log(Sun_distance*Volume/Core_Pressure)[0:n]

plt.scatter(z, y,label='Orbital');
plt.scatter(e_free[0:n],y,label='Free');

for i, txt in enumerate(planet[0:n]):
    plt.annotate(txt, (z[i], y[i]))

plt.legend()

n = 9

z = e_free[0:n]
y = np.log(Grav[0:n]*Sun_distance[0:n])

plt.scatter(e_orb[0:n], y,label='Orbital')
plt.scatter(z,y,label='Free');

for i, txt in enumerate(planet[0:n]):
    plt.annotate(txt, (z[i], y[i]))

plt.legend()

"""## Orbital"""

# Same as PCA graph

n = 9

z = e_orb[0:n]
y = (Temp)[0:n]

plt.scatter(z, y);
#plt.scatter(e_free[0:n],y,label='Free');

for i, txt in enumerate(planet[0:n]):
    plt.annotate(txt, (z[i], y[i]))

n = 9

z = e_orb[0:n]
y = np.log(Core_Pressure*Temp)[0:n]

plt.scatter(z, y);
#plt.scatter(e_free[0:n],y,label='Free');

for i, txt in enumerate(planet[0:n]):
    plt.annotate(txt, (z[i], y[i]))

plt.legend()

"""# Earth free electron analysis

## Gravity method
"""

# def orbital_free_ratio(gravity):
#   return gravity*(9.1E-31)/((6.63E-34)*(1.6E-19))

def orbital_free_ratio(gravity):
  return gravity*(9.1E-31)*(6.63E-34)/(1.6E-19)**2

def total_electrons(mass):
  return 0.49*mass/(1.672619*10**-27) # total number of electrons

"""### Feature extraction"""

# Planetary data

planet = np.array(['Merc 3.7', 'Venus 8.8', 'Earth 9.8', 'Mars 3.7', 'Jupiter 24.7', 'Saturn 10.5', 'Uranus 9.0','Neptune 11.7','Pluto 0.49', 'Sun 293.0'])
Volume = np.array([6.08*10**19,9.2843*10**20,1.0832*10**21,1.6318*10**20,1.43128*10**24,8.2713*10**23,6.833*10**22,6.254E22,6.4E18,1.4*10**27])
Pressure = np.array([101325,93*101325,101325,610,400000,140000,101325,1000E5,0.022,340000000000*101325])  # pascals
Temp = np.array([415,737,288,210,165,134,76,72,44,5778])  # kelvin
Core_Pressure = np.array([5,700,330,40,3000,4620,800,10,1.34,2.6E7])  # gigapascals (Venus unknown)
Sun_distance = np.array([0.39,0.72,1,1.52,5.2,9.54,19.2,30.06,39,0.001]) # au


Grav = np.array([3.7,8.8,9.8,3.7,24.7,10.5,9.0,11.7,0.49,293.0])  # m2s_2
mass = np.array([0.330,4.87,5.97,0.642,1898,568,86.8,1.024E2,0.01303,1989000])*10**24  # kg

orb2free_ratio = orbital_free_ratio(Grav) # = (e_orb + e_free) / e_orb  (or = eT / e_orb)
eT = total_electrons(mass)

# Note that orb2free_ratio = eT / e_orb
# and so e_orb = eT / orb2free_ratio

e_orb = eT * orb2free_ratio

e_free = eT - e_orb

print(eT)
print('')
print(e_orb)
print('')
print(e_free)

# Merc, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune, Pluto, Sun

"""### Magnetic field method"""

# Electron will have kinetic energy 1eV = 11 604.45 K
# KE = 0.5mv**2, v = np.sqrt(2*KE/me)
# F = qvB, B=F/Qv, F = mg

#nT = 1.7489338576208923e+51

q = 1.6E-19
me = 9.1E-31

# Working out magnetic field strength
relperm = 1 # air = 1, pure iron - 8000
uo = 4*np.pi*10**-7
u = relperm*uo

t = 24*60*60 # daily seconds
B = 40E-6
#B = 65000E-9

current = q/t

# Thermal energy in Earth
Tcore = 5000
Temp = 288

eV = Tcore/11604.45
Eth = eV*(1.6E-19)

Pth = 47E12 # watts Js-1
Eth = 47E12*t # thermal energy of Earth

# Energy from Sun
Ps = 2.55E14
Es = Ps*t

print(Eth, Es)

c = 0.8 # specific heat capacity of liquid iron

# Eth = m c deltaT
# Eth = mc delta T + Es
# m = (Eth - Es)/cdelta T
n_freeTH = Eth/(me*c*(Tcore-Temp))
print(n_freeTH)

r = 6371E3
k = 8.987E9
Fe = k*q**2/(r**2) # Electric force caused by one free electron from Iron core

# v = np.sqrt(2*E/me)
# B = u*n_free**(1/2)*current # 1/2 to reduce free electron volume to a free electron surface like a coil of wire (might not need this)

# n_free makes up whole sphere of Iron core, but only surface is calculated. To go from surace to volume divide by 3 increase power by 1.
# assume n_free volume = 4/3 pi r^3 then n_free Area = 4 pi r^2

n_free = (B/(u*current))**(2)
print(n_free)

n_free+n_freeTH

# (n_orb + n_free) / n_free
# expecting: 1.7489E51

# Electron will have kinetic energy 1eV = 11 604.45 K
# KE = 0.5mv**2, v = np.sqrt(2*KE/me)
# F = qvB, B=F/Qv, F = mg

#nT = 1.7489338576208923e+51

q = 1.6E-19
me = 9.1E-31

# Working out magnetic field strength
relperm = 1 # air = 1, pure iron - 8000
uo = 4*np.pi*10**-7
u = relperm*uo

t = 24*60*60 # daily seconds
B = 40E-6
#B = 65000E-9

current = q/t

# Thermal energy in Earth
Tcore = 5000
Temp = 288

eV = Tcore/11604.45
Eth = eV*(1.6E-19)

Pth = 47E12 # watts Js-1
Eth = 47E12*t # thermal energy of Earth

# Energy from Sun
Ps = 2.55E14
Es = Ps*t

print(Eth, Es)

c = 0.8 # specific heat capacity of liquid iron

# Eth = m c deltaT
# Eth = mc delta T + Es
# m = (Eth - Es)/cdelta T
n_freeTH = Eth/(me*c*(Tcore-Temp))
print(n_freeTH)

r = 6371E3
k = 8.987E9
Fe = k*q**2/(r**2) # Electric force caused by one free electron from Iron core

# v = np.sqrt(2*E/me)
# B = u*n_free**(1/2)*current # 1/2 to reduce free electron volume to a free electron surface like a coil of wire (might not need this)

# n_free makes up whole sphere of Iron core, but only surface is calculated. To go from surace to volume divide by 3 increase power by 1.
# assume n_free volume = 4/3 pi r^3 then n_free Area = 4 pi r^2

n_free = (B/(u*current))**(2)
print(n_free)

n_free+n_freeTH

# (n_orb + n_free) / n_free
# expecting: 1.7489E51

# Don't know core temps of all planets so this is estimate using Earth's core temp

#nT = 1.7489338576208923e+51

q = 1.6E-19
me = 9.1E-31
c = 0.8 # specific heat capacity of liquid iron

# Working out magnetic field strength
relperm = np.array([5000,8000,8000,8000,1,1,1,8000,1,1])              # air = 1, pure iron - 8000
B = np.array([0,0,38,0.1,550,400,32,27,0,76])*10**-6 # sufarce B_r
t = np.array([1408,5832,24,25,10,11,17,16,6.4*24,34*24])*60*60    

Temp = np.array([415,737,288,210,165,134,76,72,44,5778])  # kelvin
Tcore = np.array([8000,5160,5000,1500,20000,35000,5000,7273,1000,15E6])  # kelvin

#mass = np.array([0.330,4.87,5.97,0.642,1898,568,86.8,1.024E2,0.01303,1989000])*10**24  # kg






uo = 4*np.pi*10**-7
u = relperm*uo



current = q/t

# B = u*n_free**(1/2)*current # 1/2 to reduce free electron volume to a free electron surface like a coil of wire (might not need this)

# n_free makes up whole sphere of Iron core, but only surface is calculated. To go from surace to volume divide by 3 increase power by 1.
# assume n_free volume = 4/3 pi r^3 then n_free Area = 4 pi r^2

n_freeMG = (B/(u*current))**(2) 



# Merc, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune, Pluto, Sun
Eth = (e_free-n_freeMG)*me*c*(Tcore-Temp)

#Pth = [,,47E12,,,,,,,] # watts Js-1
#Eth = 47E12*t # thermal energy of Earth


n_freeTH = Eth/(me*c*(Tcore-Temp))




n_free = n_freeMG + n_freeTH

print(n_freeMG)
print('')
print(n_freeTH)
print('')
print(e_free)

# expecting: 1.7489E51

# Merc, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune, Pluto, Sun

nn = n_freeMG/e_free
print(nn) # check similarity
print(np.prod(nn[nn!=0]))

print(n_freeTH/e_free) # check similarity
print(np.prod(n_freeTH/e_free))

print(n_free/e_free) # check similarity
print(np.prod(n_free/e_free))

n = 9

z = e_free[0:n]



y = (np.log(n_freeMG[0:n]))
y2 = ((n_freeTH[0:n]))
y2 = np.log(y2.astype('float64'))
#y3 = e_orb[0:n]

plt.scatter(z,y,color ='b', label = 'Mag free');
plt.scatter(z,y2,color ='r', label = 'Therm free');
#plt.scatter(z,y3,color ='y', label = 'Orbital')
#plt.scatter(z,np.log(n_free[0:n]),color ='y');

for i, txt in enumerate(planet[0:n]):
    plt.annotate(txt, (z[i], y[i]))

for i, txt in enumerate(planet[0:n]):
    plt.annotate(txt, (z[i], y2[i]))

plt.legend(loc='lower right');

n = 10

z = np.log(e_orb[0:n].astype('float64'))



y = ((n_freeMG[0:n]/e_free[0:n]))
y = np.log(y.astype('float64'))

y2 = ((n_freeTH[0:n]/e_free[0:n]))
y2 = np.log(y2.astype('float64'))
#y3 = e_orb[0:n]

# Set up the axes with gridspec
fig, axes = plt.subplots(2,1, figsize=(8,8))

# Plots
axes[0].scatter(z,y,color ='b', label = 'Mag free');
axes[1].scatter(z,y2,color ='r', label = 'Therm free');
#ax3.scatter(z,y3,color ='y', label = 'Orbital')
#ax4.scatter(z,np.log(n_free[0:n]),color ='y');

for i, txt in enumerate(planet[0:n]):
    axes[0].annotate(txt, (z[i], y[i]))

for i, txt in enumerate(planet[0:n]):
    axes[1].annotate(txt, (z[i], y2[i]))

axes[0].legend(loc='lower right');
axes[1].legend(loc='lower right');

n = 10

z = np.log(e_orb[0:n].astype('float64'))



y = ((n_freeMG[0:n]))
y[y==0]=1E50
y = np.log(y.astype('float64'))

y2 = ((n_freeTH[0:n]))
y2[y2==0]=1E50
y2 = np.log(y2.astype('float64'))
#y3 = e_orb[0:n]

# Set up the axes with gridspec
fig, axes = plt.subplots(2,1, figsize=(8,8))

# Plots
axes[0].scatter(z,y,color ='b', label = 'Mag free');
axes[1].scatter(z,y2,color ='r', label = 'Therm free');
#ax3.scatter(z,y3,color ='y', label = 'Orbital')
#ax4.scatter(z,np.log(n_free[0:n]),color ='y');

for i, txt in enumerate(planet[0:n]):
    axes[0].annotate(txt, (z[i], y[i]))

for i, txt in enumerate(planet[0:n]):
    axes[1].annotate(txt, (z[i], y2[i]))

axes[0].legend(loc='lower right');
axes[1].legend(loc='lower right');

n = 10

z = np.log(e_orb[0:n].astype('float64'))



y = ((n_freeMG[0:n]))
y[y==0]=1E30
y = np.log(y.astype('float64'))

y2 = ((n_freeTH[0:n]))
y2 = np.log(y2.astype('float64'))

# Plots
plt.scatter(y,y2);

for i, txt in enumerate(planet[0:n]):
    plt.annotate(txt, (y[i], y2[i]))

plt.xlabel('Free mag')
plt.ylabel('Free therm')

n = 10

z = np.log(e_orb[0:n].astype('float64'))

y = (n_freeMG[0:n])
y[y==0]=1E30
y = np.log(y.astype('float64'))

y2 = ((n_freeTH[0:n]))
y2 = np.log(y2.astype('float64'))

# Plots
plt.scatter(y/z,y2/z);

for i, txt in enumerate(planet[0:n]):
    plt.annotate(txt, (y[i]/z[i], y2[i]/z[i]))

plt.xlabel('Free mag')
plt.ylabel('Free therm')

"""# Categorising planets"""

def orbital_free_ratio(gravity):
  return gravity*(9.1E-31)*(6.63E-34)/(1.6E-19)**2

def total_electrons(mass):
  return 0.49*mass/(1.672619*10**-27) # total number of electrons

# Planetary data

planet = np.array(['Merc 3.7', 'Venus 8.8', 'Earth 9.8', 'Mars 3.7', 'Jupiter 24.7', 'Saturn 10.5', 'Uranus 9.0','Neptune 11.7','Pluto 0.49', 'Sun 293.0'])

Volume = np.array([6.08*10**19,9.2843*10**20,1.0832*10**21,1.6318*10**20,1.43128*10**24,8.2713*10**23,6.833*10**22,6.254E22,6.4E18,1.4*10**27])
Pressure = np.array([101325,93*101325,101325,610,400000,140000,101325,1000E5,0.022,340000000000*101325])  # pascals
Temp = np.array([415,737,288,210,165,134,76,72,44,5778])  # kelvin
Core_Pressure = np.array([5,700,330,40,3000,4620,800,10,1.34,2.6E7])  # gigapascals (Venus unknown)
Sun_distance = np.array([0.39,0.72,1,1.52,5.2,9.54,19.2,30.06,39,0.001]) # au

relperm = np.array([5000,8000,8000,8000,1,1,1,8000,1,1])  # air = 1, pure iron - 8000
B = np.array([0,0,38,0.1,550,400,32,27,0,76])*10**-6  # sufarce B_r
t = np.array([1408,5832,24,25,10,11,17,16,6.4*24,34*24])*60*60  # seconds in planet day

Tcore = np.array([8000,5160,5000,1500,20000,35000,5000,7273,1000,15E6])  # kelvin

Grav = np.array([3.7,8.8,9.8,3.7,24.7,10.5,9.0,11.7,0.49,293.0])  # m2s_2
mass = np.array([0.330,4.87,5.97,0.642,1898,568,86.8,1.024E2,0.01303,1989000])*10**24  # kg

## Include Moons ##

moon = np.array(['Moon 1.6', 'Titan (Saturn) 1.4', 'Ganymede'])

VolumeM = np.array([2.1968E19,7.16E19])
PressureM = np.array([3E-10, 147E3])  # pascals
TempM = np.array([26, 94])  # kelvin
Core_PressureM = np.array([5,1.3])  # gigapascals (Venus unknown)
Sun_distanceM = np.array([1,9.5]) # au

relpermM = np.array([5000,1])  # air = 1, pure iron - 8000
BM = np.array([38/1000,0])*10**-6  # sufarce B_r
tM = np.array([708.72,15.9*24])*60*60  # seconds in planet day

TcoreM = np.array([1650,93.6])  # kelvin

GravM = np.array([1.62,1.352])  # m2s_2
massM = np.array([0.07347,0.13452])*10**24  # kg

# Attach Planets and Moons
planet = np.concatenate((planet, moon))

Volume = np.concatenate((Volume, VolumeM))
Pressure = np.concatenate((Pressure, PressureM))  # pascals
Temp = np.concatenate((Temp, TempM))  # kelvin
Core_Pressure = np.concatenate((Core_Pressure, Core_PressureM))  # gigapascals (Venus unknown)
Sun_distance = np.concatenate((Sun_distance, Sun_distanceM)) # au

relperm = np.concatenate((relperm, relpermM))  # air = 1, pure iron - 8000
B = np.concatenate((B, BM))  # sufarce B_r
t = np.concatenate((t, tM))  # seconds in planet day

Tcore = np.concatenate((Tcore, TcoreM))  # kelvin

Grav = np.concatenate((Grav, GravM))  # m2s_2
mass = np.concatenate((mass, massM)) # kg

orb2free_ratio = orbital_free_ratio(Grav) # = (e_orb + e_free) / e_orb  (or = eT / e_orb)
eT = total_electrons(mass)

# Note that orb2free_ratio = eT / e_orb
# and so e_orb = eT / orb2free_ratio

e_orb = eT * orb2free_ratio

e_free = eT - e_orb


##############################################################
#### Free electrons causing magnetic and thermal activity ####
##############################################################

q = 1.6E-19
me = 9.1E-31
c = 0.8 # specific heat capacity of liquid iron

# Working out magnetic field strength

uo = 4*np.pi*10**-7
u = relperm*uo

current = q/t

# B = u*n_free**(1/2)*current # 1/2 to reduce free electron volume to a free electron surface like a coil of wire (might not need this)

# n_free makes up whole sphere of Iron core, but only surface is calculated. To go from surace to volume divide by 3 increase power by 1.
# assume n_free volume = 4/3 pi r^3 then n_free Area = 4 pi r^2

n_freeMG = (B/(u*current))**(2) 

Eth = (e_free-n_freeMG)*me*c*(Tcore-Temp)
n_freeTH = Eth/(me*c*(Tcore-Temp))

n_free = n_freeMG + n_freeTH

print('Total electrons')
print(eT)
print('Total orbital electrons')
print(e_orb)
print('Total free electrons - gravity prediction')
print(e_free)
print('Total free electrons - magnetic & thermal prediction')
print(n_free)
print('Free electrons causing magnetic field')
print(n_freeMG)
print('Free electrons causing thermal currents')
print(n_freeTH)

# Merc, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune, Pluto, Sun + Moon, Titan

n = 12

z = np.log(e_orb[0:n].astype('float64'))

y = (n_freeMG[0:n])
y[y==0]=1E30
y = np.log(y.astype('float64'))

y2 = ((n_freeTH[0:n]))
y2 = np.log(y2.astype('float64'))

# Plots
plt.scatter(y/z,y2/z);

for i, txt in enumerate(planet[0:n]):
    plt.annotate(txt, (y[i]/z[i], y2[i]/z[i]))

plt.xlabel('Free electron mag per orbital electron')
plt.ylabel('Free electron therm per orbital electron')

# Atmosphere zone (blue dash)
plt.plot(np.linspace(1.1,1.8,10),2.05*np.ones(10),'--', color = 'lightblue', linewidth = 0.8)
plt.plot(np.linspace(1.1,1.8,10),1.95*np.ones(10),'--', color = 'k', linewidth = 0.8)
plt.plot(np.linspace(1.1,1.8,10),1.9*np.ones(10),'--', color = 'g', linewidth = 0.8)
plt.plot(np.linspace(1.1,1.8,10),1.8*np.ones(10),'--', color = 'r', linewidth = 0.8)

"""# Finding gravity equation"""

print((n_freeTH[0:n])/(e_orb[0:n].astype('float64')))
planet
ag = [3.7,8.8,9.8,3.7,24.7,10.5,9.0,11.7,0.49,293,1.6,1.4]
print(ag)

plt.scatter(ag,(n_freeTH[0:n])/(e_orb[0:n].astype('float64')))

# Finding out the constant

k = ag*(n_freeTH[0:n])/(e_orb[0:n].astype('float64'))
k = np.mean(k)
k

print((n_freeTH[0:n])/(e_orb[0:n].astype('float64')))
planet
ag = [3.7,8.8,9.8,3.7,24.7,10.5,9.0,11.7,0.49,293,1.6,1.4]
print(ag)

plt.scatter(ag,(n_freeTH[0:n])/(e_orb[0:n].astype('float64')))

x = np.linspace(0,300,1000)

y = k/x

plt.plot(x,y)

"""# Testing gravity equation"""

x = np.linspace(0,1.5E26,5000)
ag = k/x
plt.plot(x,ag);

plt.xlabel('Thermal to orbital electron ratio')
plt.ylabel('Acceleration due to gravity')

# Finding out the constant

k = ag[0:n]*(n_freeTH[0:n])/(e_orb[0:n].astype('float64'))
k = np.mean(k)
ag = [3.7,8.8,9.8,3.7,24.7,10.5,9.0,11.7,0.49,293,1.6,1.4]

plt.scatter(ag[0:n],(n_freeTH[0:n])/(e_orb[0:n].astype('float64')));

x = np.linspace(0,300,1000)
y = k/x

plt.plot(x,y);

for i, txt in enumerate(planet[0:n]):
    plt.annotate(txt, (ag[i], (n_freeTH[i])/(e_orb[i])))

plt.ylabel('Thermal to orbital electron ratio')
plt.xlabel('Acceleration due to gravity')

# Finding out the constant
n = 12

ratio = (n_freeTH[0:n])/(e_orb[0:n].astype('float64'))

ag = [3.7,8.8,9.8,3.7,24.7,10.5,9.0,11.7,0.49,293,1.6,1.4][0:n]

plt.scatter(ag,np.log(np.log(np.log(np.log(ratio.astype(float))))));

x = np.linspace(min(ag),max(ag))  # 2E9 for neutron star
k = ag*ratio
k = np.mean(k)
y = k/x

plt.plot(x,np.log(np.log(np.log(np.log(y)))));

for i, txt in enumerate(planet[0:n]):
    plt.annotate(txt, (ag[i], np.log(np.log(np.log(np.log((n_freeTH[i])/(e_orb[i])))))))

plt.ylabel('Log thermal to orbital electron ratio')
plt.xlabel('Acceleration due to gravity')

k

# Finding out the constant
n = 12

ratio = (n_free[0:n])/(e_orb[0:n].astype('float64'))

ag = [3.7,8.8,9.8,3.7,24.7,10.5,9.0,11.7,0.49,293,1.6,1.4][0:n]

plt.scatter(ag,np.log(np.log(np.log(np.log(ratio.astype(float))))));

x = np.linspace(min(ag),max(ag))  # 2E9 for neutron star
k = ag*ratio
k = np.mean(k)
y = k/x

plt.plot(x,np.log(np.log(np.log(np.log(y)))));

for i, txt in enumerate(planet[0:n]):
    plt.annotate(txt, (ag[i], np.log(np.log(np.log(np.log((n_free[i])/(e_orb[i])))))))

plt.ylabel('Log total electrons to orbital electron ratio')
plt.xlabel('Acceleration due to gravity')

k

n = 4

z = (e_orb[0:n].astype('float64'))

y = (n_freeMG[0:n])
y[y==0]=1E30
y = (y.astype('float64'))

y2 = ((n_free[0:n]))
y2 = (y2.astype('float64'))

plt.scatter(z/y2,9.10938356E-31*k*(z/y2))

for i, txt in enumerate(planet[0:n]):
    plt.annotate(txt, (z[i]/y2[i], 9.10938356E-31*k*(z[i]/y2[i])))

x = np.linspace(0,np.sqrt(1/n)*1E-24,5000)
F = 9.10938356E-31*k*x

plt.plot(x,F);

plt.xlabel('Orbital to total electron ratio')
plt.ylabel('Force per electron causing gravity')

k

# Finding out the constant
n = 12

ratio = (n_freeTH[0:n])/(e_orb[0:n].astype('float64'))

ag = [3.7,8.8,9.8,3.7,24.7,10.5,9.0,11.7,0.49,293,1.6,1.4][0:n]

plt.scatter(ag,np.log(np.log(np.log(np.log(ratio.astype(float))))));

x = np.linspace(min(ag),max(ag))  # 2E9 for neutron star
k = ag*ratio
k = np.mean(k)
y = k/x

plt.plot(x,np.log(np.log(np.log(np.log(y)))));

for i, txt in enumerate(planet[0:n]):
    plt.annotate(txt, (ag[i], np.log(np.log(np.log(np.log((n_freeTH[i])/(e_orb[i])))))))

plt.ylabel('Log thermal to orbital electron ratio')
plt.xlabel('Acceleration due to gravity')

k

x = np.linspace(0,1.5E26,5000)
F = 9.10938356E-31*k*x

plt.plot(x,F);

plt.xlabel('Total electrons and Orbital to thermal electron ratio')
plt.ylabel('Force due to gravity')

n = 4

z = (e_orb[0:n].astype('float64'))

y = (n_freeMG[0:n])
y[y==0]=1E30
y = (y.astype('float64'))

y2 = ((n_freeTH[0:n]))
y2 = (y2.astype('float64'))

plt.scatter(z/y2,9.10938356E-31*k*(z/y2))

for i, txt in enumerate(planet[0:n]):
    plt.annotate(txt, (z[i]/y2[i], 9.10938356E-31*k*(z[i]/y2[i])))

x = np.linspace(0,np.sqrt(1/n)*1E-24,5000)
F = 9.10938356E-31*k*x

plt.plot(x,F);

plt.xlabel('Orbital to thermal electron ratio')
plt.ylabel('Force per electron causing gravity')

n = 12

z = (e_orb[0:n].astype('float64'))

y = (n_freeMG[0:n])
y[y==0]=1E30
y = (y.astype('float64'))

y2 = ((n_free[0:n]))
y2 = (y2.astype('float64'))

plt.scatter(z/y2,9.10938356E-31*k*(z/y2))

for i, txt in enumerate(planet[0:n]):
    plt.annotate(txt, (z[i]/y2[i], 9.10938356E-31*k*(z[i]/y2[i])))

x = np.linspace(0,1E-24,5000)
F = 9.10938356E-31*k*x

plt.plot(x,F);

plt.xlabel('Orbital to thermal electron ratio')
plt.ylabel('Force per electron causing gravity')

E = 9.10938356E-31*k*(z[3]/y2[3])*eT[3]  # gravitational potential force of Earth based on number of electrons

S = 9.10938356E-31*k*(z[11]/y2[11])*eT[11]  # gravitational potential force of Sun based on number of electrons

E+S


# 3.54E22 force between Sun and Earth

# Gravity equation with temperature
n= 12

planet
ag = [3.7,8.8,9.8,3.7,24.7,10.5,9.0,11.7,0.49,293,1.6,1.4]
print(ag)

plt.scatter(ag[0:n],np.log(Tcore[0:n])/(e_orb[0:n].astype('float64')))

# Finding out the constant using core temp

k = (np.log(Tcore[0:n])/(e_orb[0:n].astype('float64')))/ag[0:n]
k = np.mean(k)

x = np.linspace(0,300,5000)
y = k/x  # where y is temp/orbital, x is gravity at surface


plt.scatter(ag[0:n],np.log(Tcore[0:n])/(e_orb[0:n].astype('float64')))
plt.plot(x,y)

k

# Finding out the constant using surface temp

k = (np.log(Temp[0:n])/(e_orb[0:n].astype('float64')))/ag[0:n]
k = np.mean(k)

x = np.linspace(0,300,5000)
y = k/x  # where y is temp/orbital, x is gravity at surface


plt.scatter(ag[0:n],np.log(Temp[0:n])/(e_orb[0:n].astype('float64')))
plt.plot(x,y)

k

"""# Wave mathematics

## 2D
"""

A = 1
f = 1
xL = 10

x = np.linspace(-xL,xL,1000)
y = A*np.sin(f*x)
plt.plot(x,y)

plt.xlim(-100,100)
plt.ylim(-100,100)

A = 1
f = 1
xL = 1

x = np.linspace(-xL,xL,1000)
y = A*np.sin(f*x)
plt.plot(x,y)

plt.xlim(-100,100)
plt.ylim(-100,100)

A = 1
f = 1
xL = 100000

x = np.linspace(-xL,xL,1000)
y = A*np.sin(f*x)
plt.plot(x,y)

plt.xlim(-100,100)
plt.ylim(-100,100)

A = 10000
f = 0.01
xL = 0.3

x = np.linspace(-xL,xL,1000)
y = A*np.sin(f*x)
plt.plot(x,y)

plt.xlim(-100,100)
plt.ylim(-100,100)

A = 1000
f = 0.001
xL = 50

x = np.linspace(-xL,xL,1000)
y = A*np.sin(f*x)
plt.plot(x,y)

plt.xlim(-100,100)
plt.ylim(-100,100)

A = 10
f = 100000000
xL = 10

x = np.linspace(-xL,xL,1000)
y = A*np.sin(f*x)
plt.plot(x,y)

plt.xlim(-100,100)
plt.ylim(-100,100)

A = 10
f = 100000000
xL = 10

u = np.linspace(-xL,xL,1000)-25

x = 10*np.sin(f*u)
y = 30*np.sin(0.5*f*u)+25
plt.plot(x,y)

plt.xlim(-100,100)
plt.ylim(-100,100)

A = 10
f = 100000000
xL = 10

x = np.linspace(-xL,xL,1000)
y = A*np.sin(f*x)+25*np.sin(np.pi*f*x)-50
plt.plot(x,y)

plt.xlim(-100,100)
plt.ylim(-100,100)

A = 10
f = 100000000
xL = 20

x = np.linspace(-xL,xL,1000)
y = A*np.sin(f*x)+25*np.sin(np.pi*f*x)-50
plt.plot(x,y)

plt.xlim(-100,100)
plt.ylim(-100,100)

"""## 3D"""

A = 10
f = 1000000000
xL = 10

x = np.linspace(-xL,xL,1000)

ax = plt.axes(projection='3d')

# Data for a three-dimensional line
zline = 2/15*A*np.sin(100*f*x)
xline = 5*A*np.sin(0.1*f*x)
yline = 10*A*np.sin(f*(100*A*np.sin(f*x)))
ax.plot3D(xline, yline, zline, 'gray')

plt.xlim(-500,500)
plt.ylim(-500,500)


ax.view_init(30, 70)

A = 10
f = 100
xL = 10

x = np.linspace(-xL,xL,1000)

ax = plt.axes(projection='3d')

# Data for a three-dimensional line
zline = 2/15*A*np.sin(100*f*x)
xline = 50*A*np.sin(20*f*(100*A*np.sin(0.02*f*x)))
yline = 10*A*np.sin(0.02*f*(100*A*np.sin(0.02*f*x)))
ax.plot3D(xline, yline, zline, 'gray')


#x = 10*np.sin(f*u)
#y = 30*np.sin(0.5*f*u)+25

plt.xlim(-500,500)
plt.ylim(-500,500)


ax.view_init(30, 70)

A = 10
f = 100
xL = 10

x = np.linspace(-xL,xL,1000)

ax = plt.axes(projection='3d')

# Data for a three-dimensional line
zline = 2*A*np.sin(100*f*x)
xline = 10*A*np.sin(20*f*(100*A*np.sin(0.02*f*x)))
yline = 30*A*np.sin(0.02*f*(100*A*np.sin(0.02*f*x)))
ax.plot3D(xline, yline, zline, 'gray')


#x = 10*np.sin(f*u)
#y = 30*np.sin(0.5*f*u)+25

plt.xlim(-500,500)
plt.ylim(-500,500)


ax.view_init(30, 70)

# 1x1x1 cube
A = 1
f = 10
xL = 10

x = np.linspace(-xL,xL,1000)

ax = plt.axes(projection='3d')

# Data for a three-dimensional line
zline = A*np.sin(100*f*x)
xline = A*np.sin(20*f*(100*A*np.sin(0.02*f*x)))
yline = A*np.sin(0.02*f*(100*A*np.sin(0.02*f*x)))
ax.plot3D(xline, yline, zline, 'gray')


#x = 10*np.sin(f*u)
#y = 30*np.sin(0.5*f*u)+25

plt.xlim(-4*A,4*A)
plt.ylim(-4*A,4*A)


ax.view_init(30, 70)

"""## Cuboid"""

# 8x7x2 cube
Ax = 8
Ay = 7
Az = 2

f = 10
xL = 10

x = np.linspace(-xL,xL,1000)

ax = plt.axes(projection='3d')

# Data for a three-dimensional line
zline = Az*np.sin(100*f*x)
xline = Ax*np.sin(20*f*(100*A*np.sin(0.02*f*x)))
yline = Ay*np.sin(0.02*f*(100*A*np.sin(0.02*f*x)))
ax.plot3D(xline, yline, zline, 'gray')

plt.xlim(-2*(Ax+Ay),2*(Ax+Ay))
plt.ylim(-2*(Ax+Ay),2*(Ax+Ay))


ax.view_init(30, 70)

A = 10

Ax = 1
Ay = 1
Az = 1

f = 1000000000
xL = 10

s = 2 # size of cubes
n = 4 # number of cubes

x = np.linspace(-xL,xL,1000)

ax = plt.axes(projection='3d')

# Data for a three-dimensional line
xline = Ax*np.sin(20*f*(100*A*np.sin(0.02*f*x)))*n
yline = Ay*np.sin(0.02*f*(100*A*np.sin(0.02*f*x)))*n
zline = Az*np.sin(100*f*x)*n
ax.plot3D(xline, yline, zline, 'gray')

# Data for a three-dimensional line
xline = Ax*np.sin(20*f*(100*A*np.sin(0.02*f*x)))*n
yline = Ay*np.sin(0.02*f*(100*A*np.sin(0.02*f*x)))*n
zline = Az*np.sin(100*f*x)*n-20
ax.plot3D(xline, yline, zline, 'gray')

# Data for a three-dimensional line
xline = Ax*np.sin(20*f*(100*A*np.sin(0.02*f*x)))*n-20
yline = Ay*np.sin(0.02*f*(100*A*np.sin(0.02*f*x)))*n
zline = Az*np.sin(100*f*x)*n
ax.plot3D(xline, yline, zline, 'gray')

# Data for a three-dimensional line
xline = Ax*np.sin(20*f*(100*A*np.sin(0.02*f*x)))*n 
yline = Ay*np.sin(0.02*f*(100*A*np.sin(0.02*f*x)))*n -20
zline = Az*np.sin(100*f*x)*n
ax.plot3D(xline, yline, zline, 'gray')

# Data for a three-dimensional line
xline = Ax*np.sin(20*f*(100*A*np.sin(0.02*f*x)))*n +20
yline = Ay*np.sin(0.02*f*(100*A*np.sin(0.02*f*x)))*n
zline = Az*np.sin(100*f*x)*n
ax.plot3D(xline, yline, zline, 'gray')

# Data for a three-dimensional line
xline = Ax*np.sin(20*f*(100*A*np.sin(0.02*f*x)))*n 
yline = Ay*np.sin(0.02*f*(100*A*np.sin(0.02*f*x)))*n +20
zline = Az*np.sin(100*f*x)*n
ax.plot3D(xline, yline, zline, 'gray')


plt.xlim(-10*(Ax+Ay),10*(Ax+Ay))
plt.ylim(-10*(Ax+Ay),10*(Ax+Ay))


ax.view_init(30, 70)

"""## Spiky cube"""

# 8x7x2 cube
Ax = 10
Ay = 10
Az = 10

f = 10
xL = 10

x = np.linspace(-xL,xL,1000)

ax = plt.axes(projection='3d')

# Data for a three-dimensional line
xline = (Ax*np.sin(20*f*(100*A*np.sin(0.02*f*x))))+(Ax*np.sin(20*f*(100*A*np.cos(0.02*f*x))))
yline = (Ay*np.sin(0.02*f*(100*A*np.sin(0.02*f*x))))+(Ay*np.sin(0.02*f*(100*A*np.cos(0.02*f*x))))
zline = (Az*np.sin(100*f*x))+(Az*np.cos(100*f*x))
ax.plot3D(xline, yline, zline, 'gray')

plt.xlim(-2*(Ax+Ay),2*(Ax+Ay))
plt.ylim(-2*(Ax+Ay),2*(Ax+Ay))


ax.view_init(30, 70)

"""## Mobius strip"""

# 8x7x2 cube
Ax = 8
Ay = 5
Az = 2

f = 10000
xL = 1

x = np.linspace(-xL,xL,1000)
ax = plt.axes(projection='3d')

# Data for a three-dimensional line
xline = Ax*np.cos(f*x)*np.sin(f*x)
yline = Ay*np.sin(f*x)*np.sin(f*x)
zline = Az*np.sin(f*x)
ax.plot3D(xline, yline, zline, 'gray')

plt.xlim(-2*(Ax+Ay),2*(Ax+Ay))
plt.ylim(-2*(Ax+Ay),2*(Ax+Ay))


ax.view_init(30, 70)

"""## Smoother wall"""

# 8x7x2 
Ax = 4
Ay = 0.01
Az = 4

f = 100000
xL = 1

x = np.linspace(-xL,xL,1000)
ax = plt.axes(projection='3d')

# Data for a three-dimensional line
xline = Ax*np.sin(f*np.sin(f*x))*np.cos(f*np.cos(f*x))+Ax*np.sin(f*np.sin(f*x))*np.cos(f*np.cos(f*x))
yline = Ay*np.cos(f*Ay*np.cos(f*x))+Ay*np.cos(f*Ay*np.cos(f*x))
zline = Az*np.sin(f*Az*np.sin(f*x))*np.sin(f*Az*np.sin(f*x))
ax.plot3D(xline, yline, zline, 'gray')

plt.xlim(-2*(Ax+Ay),2*(Ax+Ay))
plt.ylim(-2*(Ax+Ay),2*(Ax+Ay))


ax.view_init(20, 70)

"""## Sphere"""

# 8x7x2 
Ax = 40
Ay = 0.00001
Az = 10

f = 100000
xL = 1

x = np.linspace(-xL,xL,1000)
ax = plt.axes(projection='3d')

# Data for a three-dimensional line
xline = Ax*np.sin(f*x)**7
yline = Ay*np.cos(f*x)**7
zline = Az*np.sin(f*x)**-7
ax.plot3D(xline, yline, zline, 'gray')

plt.xlim(-2*(Ax+Ay),2*(Ax+Ay))
plt.ylim(-2*(Ax+Ay),2*(Ax+Ay))


ax.view_init(20, 70)

# 8x7x2 
Ax = 10
Ay = 10
Az = 10

f = 100000
xL = 1

x = np.linspace(-xL,xL,1000)
ax = plt.axes(projection='3d')

# Data for a three-dimensional line
xline = Ax*np.sin(f*x)**7
yline = Ay*np.cos(f*x)**5
zline = Az*np.sin(f*x)**-5
ax.plot3D(xline, yline, zline, 'gray')

plt.xlim(-2*(Ax+Ay),2*(Ax+Ay))
plt.ylim(-2*(Ax+Ay),2*(Ax+Ay))


ax.view_init(20, 70)

# 8x7x2 
Ax = 10000
Ay = 10000
Az = 10000

f = 10000000
xL = 100

x = np.linspace(-xL,xL,1000)
ax = plt.axes(projection='3d')

#532 #53-2 #534 #234 #834 #531,542
# Data for a three-dimensional line
xline = Ax*np.sin(f*x)**2+Ax*np.cos(f*x)**2
yline = Ay*np.cos(f*x)**2+Ax*np.sin(f*x)**2
zline = Az*np.cos(f*x)**5+Ax*np.sin(f*x)**2
ax.plot3D(xline, yline, zline, 'gray')

plt.xlim(-2*(Ax+Ay),2*(Ax+Ay))
plt.ylim(-2*(Ax+Ay),2*(Ax+Ay))


ax.view_init(50, 70)

A = 10

Ax = 1
Ay = 1
Az = 1

f = 1000000000
xL = 10

s = 2 # size of cubes
n = 4 # number of cubes

x = np.linspace(-xL,xL,1000)

ax = plt.axes(projection='3d')

# Data for a three-dimensional line
xline = Ax*np.sin(20*f*(100*A*np.sin(0.02*f*x)))*n
yline = Ay*np.sin(0.02*f*(100*A*np.sin(0.02*f*x)))*n
zline = Az*np.sin(100*f*x)*n
ax.plot3D(xline, yline, zline, 'gray')

# Data for a three-dimensional line
xline = Ax*np.sin(20*f*(100*A*np.sin(0.02*f*x)))*n
yline = Ay*np.sin(0.02*f*(100*A*np.sin(0.02*f*x)))*n
zline = Az*np.sin(100*f*x)*n-20
ax.plot3D(xline, yline, zline, 'gray')

# Data for a three-dimensional line
xline = Ax*np.sin(20*f*(100*A*np.sin(0.02*f*x)))*n-20
yline = Ay*np.sin(0.02*f*(100*A*np.sin(0.02*f*x)))*n
zline = Az*np.sin(100*f*x)*n
ax.plot3D(xline, yline, zline, 'gray')

# Data for a three-dimensional line
xline = Ax*np.sin(20*f*(100*A*np.sin(0.02*f*x)))*n 
yline = Ay*np.sin(0.02*f*(100*A*np.sin(0.02*f*x)))*n -20
zline = Az*np.sin(100*f*x)*n
ax.plot3D(xline, yline, zline, 'gray')

# Data for a three-dimensional line
xline = Ax*np.sin(20*f*(100*A*np.sin(0.02*f*x)))*n +20
yline = Ay*np.sin(0.02*f*(100*A*np.sin(0.02*f*x)))*n
zline = Az*np.sin(100*f*x)*n
ax.plot3D(xline, yline, zline, 'gray')

# Data for a three-dimensional line
xline = Ax*np.sin(20*f*(100*A*np.sin(0.02*f*x)))*n 
yline = Ay*np.sin(0.02*f*(100*A*np.sin(0.02*f*x)))*n +20
zline = Az*np.sin(100*f*x)*n
ax.plot3D(xline, yline, zline, 'gray')


plt.xlim(-10*(Ax+Ay),10*(Ax+Ay))
plt.ylim(-10*(Ax+Ay),10*(Ax+Ay))


ax.view_init(30, 70)

"""# Using wave mathematics to model a planet"""

def model_cube(X,Y,Z, ef,space, position):
  xline = X*np.sin(20*ef*(1000*np.sin(0.02*ef*space)))*n + position[0]
  yline = Y*np.sin((0.5)*ef*(1000*np.sin(0.02*ef*space)))*n + position[1]
  zline = Z*np.sin(0.01*ef*space)*n + position[2]
  ax.plot3D(xline, yline, zline, 'gray')

def model_planet(X,Y,Z,type,space,position):
  orbital_cube = model_cube(X,Y,Z,e_orb[type],space,position)
  thermal_cube = model_cube(X,Y,Z,n_freeTH[type],space,position)
  magnetic_cube = model_cube(X,Y,Z,n_freeMG[type],space,position)
  return orbital_cube,thermal_cube, magnetic_cube

s = 1 # Amp of waves (eV of electron waves)

Ax = 1*s
Ay = 1*s
Az = 1*s

f = 1000000000
xL = 10
n = 4 # size of cubes

x = np.linspace(-xL,xL,1000)
ax = plt.axes(projection='3d')

# Sun
sun = 9

# Earth
d = 1.496E11  # 1AU
earth = 2

orbital1, thermal1, magnetic1 = model_planet(Ax,Ay,Az,sun,x,[0,0,0])
orbital2, thermal2, magnetic2 = model_planet(Ax,Ay,Az,earth,x,[d,0,0])

plt.xlim(-10*(Ax+Ay)-d,10*(Ax+Ay)+d)
plt.ylim(-10*(Ax+Ay)-d,10*(Ax+Ay)+d)
ax.view_init(30, 70)

# Gravitational Force between the planets

# This theory suggests that it's only based on orbital electrons and electrostatic force (perhaps convolution of electrostatic force)

e_orb[sun]
e_orb[earth]

# Electrostatic forces within planet F = kq1q2/r**2
k = 8.98755E9
FE = k*(1.6E-19*e_orb[earth])/((6371E3)**2)
FS =k*(1.6E-19*e_orb[sun])/((696340E3)**2)
FE+FS
#exp 3.557E22

"""# Ring mathematics

## Install pyvista
"""

pip install pyvista

import pyvista as pv

# setup enviornment for interactive plotting
!apt-get install -qq xvfb
!pip install pyvista panel -q

import os
os.system('/usr/bin/Xvfb :99 -screen 0 1024x768x24 &')
os.environ['DISPLAY'] = ':99'

import panel as pn
pn.extension('vtk')

# ### new cell spline example cell ###
# pn.extension('vtk')  # this needs to be at the top of each cell for some reason

"""## 2D"""

import numpy as np
import matplotlib.pyplot as plt

theta = np.linspace(0, 2*np.pi, 100)

r = np.sin(2*theta)

x1 = r*np.cos(theta)
x2 = r*np.sin(theta)

fig, ax = plt.subplots(1)

ax.plot(x1, x2)
ax.set_aspect(1)


plt.grid(linestyle='--')

theta = np.linspace(0, 2*np.pi, 100)

r = np.sin(10*theta)

x1 = r*np.cos(theta)
x2 = r*np.sin(theta)

plt.plot(x1, x2)


r = np.sin(theta+20)

x1 = r*np.cos(theta)
x2 = r*np.sin(theta)

plt.plot(x1, x2)


r = np.sin(theta+100)

x1 = r*np.cos(theta)
x2 = r*np.sin(theta)

plt.plot(x1, x2)


r = np.sin(theta+147)

x1 = r*np.cos(theta)
x2 = r*np.sin(theta)

plt.plot(x1, x2)

theta = np.linspace(0, 2*np.pi, 100)

r = np.sin(10*theta)+np.sin(theta+20)+np.sin(theta+100)+np.sin(theta+147)

x1 = r*np.cos(theta)
x2 = r*np.sin(theta)

plt.plot(x1, x2)

"""### Discrete polar"""

print(sum([1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1]))
plt.polar([1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0]);

plt.polar([1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]);

plt.polar([0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]);

"""## 3D"""

# setup enviornment for interactive plotting
!apt-get install -qq xvfb
!pip install pyvista panel -q

import os
os.system('/usr/bin/Xvfb :99 -screen 0 1024x768x24 &')
os.environ['DISPLAY'] = ':99'

import panel as pn
pn.extension('vtk')

# ### new cell spline example cell ###
# pn.extension('vtk')  # this needs to be at the top of each cell for some reason

# n_points = 100
# theta = np.linspace(-4 * np.pi, 4 * np.pi, n_points)
# z = np.linspace(-2, 2, n_points)
# r = z ** 2 + 1
# x = r * np.sin(theta)
# y = r * np.cos(theta)
# points = np.column_stack((x, y, z))

# # Create spline with 1000 interpolation points
# spline = pv.Spline(points, 1000)

# # add scalars to spline and plot it
# spline["scalars"] = np.arange(spline.n_points)
# tube = spline.tube(radius=0.1)
# tube.plot(smooth_shading=True, notebook=True)

"""## Proof sine in polar converges to circle"""

# setup enviornment for interactive plotting

import os
os.system('/usr/bin/Xvfb :99 -screen 0 1024x768x24 &')
os.environ['DISPLAY'] = ':99'

import panel as pn
pn.extension('vtk')

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = np.sin(100*theta)+np.sin(100*theta)
x = r * np.sin(theta)
y = r * np.cos(theta)
points = np.column_stack((x, y, z))

# Create spline with 1000 interpolation points
spline = pv.Spline(points, 100)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=0.02)
tube.plot(smooth_shading=True, notebook=True)


### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = np.sin(5*theta)+np.sin(5*theta)
x = r * np.sin(theta)
y = r * np.cos(theta)
points = np.column_stack((x, y, z))

# Create spline with 1000 interpolation points
spline = pv.Spline(points, 100)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=0.02)
tube.plot(smooth_shading=True, notebook=True)

"""## Two perpendicular force rings"""

# setup enviornment for interactive plotting

import os
os.system('/usr/bin/Xvfb :99 -screen 0 1024x768x24 &')
os.environ['DISPLAY'] = ':99'

import panel as pn
pn.extension('vtk')

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason

f = 100

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
x = r * np.sin(theta)
y = r * np.cos(theta)
points = np.column_stack((x, y, z))



theta = np.linspace(-np.pi, np.pi, n_points)
z = y 
r = r
x = x
y = np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))

# Create spline with 1000 interpolation points
spline = pv.Spline(points, 100)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=0.02)
tube.plot(smooth_shading=True, notebook=True);

"""## Quantum entanglement ?"""

# setup enviornment for interactive plotting

import os
os.system('/usr/bin/Xvfb :99 -screen 0 1024x768x24 &')
os.environ['DISPLAY'] = ':99'

import panel as pn
pn.extension('vtk')

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason

f = 2

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
x = r * np.sin(theta)
y = r * np.cos(theta)
points = np.column_stack((x, y, z))


theta = np.linspace(-np.pi, np.pi, n_points)
z = x 
r = r
x = np.linspace(0, 0, n_points)
y = y
points = np.concatenate((points,np.column_stack((x-f, y, z+f))))

# Create spline with 1000 interpolation points
spline = pv.Spline(points, 100)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=0.02)
tube.plot(smooth_shading=True, notebook=True);

"""# New coordinate system"""

# setup enviornment for interactive plotting

import os
os.system('/usr/bin/Xvfb :99 -screen 0 1024x768x24 &')
os.environ['DISPLAY'] = ':99'

import panel as pn
pn.extension('vtk')

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason

A = 20
f = 1

T = 1/f

# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
x = r * np.sin(theta)*A
y = r * np.cos(theta)*A
points = np.column_stack((x, y, z))


# Vertical rings 

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x+A, y, z))))

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x-A, y, z))))

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * np.linspace(0, 0, n_points)
y = A * r * np.sin(theta)
points = np.concatenate((points,np.column_stack((x+T-T*A*(A**-1-f), y-T-A-(A**-1-T)*T*A+2, z)))) # x+A+T-T*A

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * np.linspace(0, 0, n_points)
y = A * r * np.sin(theta)
points = np.concatenate((points,np.column_stack((x+T-T*A*(A**-1-f), y+T-A+(A**-1-T)*T*A-2, z)))) # x+A+T-T*A

# Create spline with 1000 interpolation points
spline = pv.Spline(points, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

# setup enviornment for interactive plotting

import os
os.system('/usr/bin/Xvfb :99 -screen 0 1024x768x24 &')
os.environ['DISPLAY'] = ':99'

import panel as pn
pn.extension('vtk')

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason

A = 2
f = 2

T = 1/f

# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
x = r * np.sin(theta)*A
y = r * np.cos(theta)*A
points = np.column_stack((x, y, z))


# Vertical rings 

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x+A, y, z))))

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x-A, y, z))))


# Vertical rotated by 90

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * np.linspace(0, 0, n_points)
y = A * r * np.sin(theta)
points = np.concatenate((points,np.column_stack((x+T-T*A*(A**-1-T), y-T-A-(A**-1-f)*T*A+2*T, z))))  # green

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * np.linspace(0, 0, n_points)
y = A * r * np.sin(theta)
points = np.concatenate((points,np.column_stack((x+T-T*A*(A**-1-T), y+T-A+(A**-1-f)*T*A-2*T, z))))  # yellow

# Create spline with 1000 interpolation points
spline = pv.Spline(points, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

"""## Final model"""

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason

A = 1
f = 1

T = 1/f

# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (np.sin(f*theta))+(np.sin(f*theta))
x = r * np.sin(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * np.cos(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))



# Create spline with 1000 interpolation points
spline = pv.Spline(points, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

"""## Creation of a sphere"""

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason

A = 1
f = 99

T = 1/f

# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (np.sin(f*theta))+(np.sin(f*theta))
x = r * np.sin(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * np.cos(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))



# Create spline with 1000 interpolation points
spline = pv.Spline(points, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

"""# 3D modelling"""

# setup enviornment for interactive plotting

import os
os.system('/usr/bin/Xvfb :99 -screen 0 1024x768x24 &')
os.environ['DISPLAY'] = ':99'

import panel as pn
pn.extension('vtk')

"""## Sphere"""

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 1
f = 99

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (np.sin(f*theta))+(np.sin(f*theta))
x = r * np.sin(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * np.cos(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))






# Create spline with 1000 interpolation points
spline = pv.Spline(points, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

"""## Two relative models"""

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 2
f = 2

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (np.sin(f*theta))+(np.sin(f*theta))
x = r * np.sin(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * np.cos(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))



# object 2

A = 1/2
f = 2

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (np.sin(f*theta))+(np.sin(f*theta))
x = r * np.sin(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * np.cos(theta)*A
points = np.concatenate((points,np.column_stack((x, y, z))))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))


# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

"""## Object"""

def objct(points,A,f,n_points,X,Y,Z):

  T = 1/f
  # Horizontal ring


  theta = np.linspace(-np.pi, np.pi, n_points)
  z = np.linspace(0, 0, n_points)
  r = (np.sin(f*theta))+(np.sin(f*theta))
  x = r * np.sin(theta)*A-A/(2*np.pi*f)**(f-1)
  y = r * np.cos(theta)*A
  if len(points) == 1:
    points = np.column_stack((x+X, y+Y, z+Z))
  else:
    points = np.concatenate((points,np.column_stack((x+X, y+Y, z+Z))))
    

  # Vertical ring

  theta = np.linspace(-np.pi, np.pi, n_points)
  r = np.sin(f*theta)+np.sin(f*theta)
  z = r * np.cos(theta) 
  x = A * r * np.sin(theta)
  y = A * np.linspace(0, 0, n_points)
  points = np.concatenate((points,np.column_stack((x+X, y+Y, z+Z))))


  theta = np.linspace(-np.pi, np.pi, n_points)
  r = np.sin(f*theta)+np.sin(f*theta)
  z = r * np.cos(theta) 
  x = A * r * np.sin(theta)
  y = A * np.linspace(0, 0, n_points)
  points = np.concatenate((points,np.column_stack((x+X, y+Y, z+Z))))

  import scipy

  rotation_degrees = 90
  rotation_radians = np.radians(rotation_degrees)
  rotation_axis = np.array([0, 0, 1])

  rotation_vector = rotation_radians * rotation_axis
  rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
  rotated_vec = rotation.apply(np.column_stack((x, y, z)))
  rotated_vec[:,0] = rotated_vec[:,0] + X  # xaxis
  rotated_vec[:,1] = rotated_vec[:,1] + Y  # yaxis
  rotated_vec[:,2] = rotated_vec[:,2] + Z  # zaxis
  points = np.concatenate((points,rotated_vec))

  return points

"""## Modelling"""

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 2
f = 2
n_points = 400

points = [0]

points = objct(points,A,f,n_points,0,0,0)



# object 2

A = 1/10
f = 20
X = [10,0,3]
n_points = 100

points = objct(points,A,f,n_points,X[0],X[1],X[2])


# object 3

A = 1/100
f = 10
X = [20,5,3]
n_points = 100

points = objct(points,A,f,n_points,X[0],X[1],X[2])


# object 4

A = 5
f = 90
X = [25,5,-10]
n_points = 100

points = objct(points,A,f,n_points,X[0],X[1],X[2])


# object 5

A = 2
f = 20
X = [15,15,-10]
n_points = 100

points = objct(points,A,f,n_points,X[0],X[1],X[2])


# object 6

A = 2
f = 50
X = [15,30,6]
n_points = 100

points = objct(points,A,f,n_points,X[0],X[1],X[2])


# object 6

A = 1/2
f = 10
X = [15,30,10]
n_points = 100

points = objct(points,A,f,n_points,X[0],X[1],X[2])


# object 6

A = 2
f = 20
X = [15,30,10]
n_points = 100

points = objct(points,A,f,n_points,X[0],X[1],X[2])



# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points, 10000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 1
f = 100
n_points = 1000

points = [0]

points = objct(points,A,f,n_points,0,0,0)



# object 2

A = 1
f = 100
X = [10,0,3]
n_points = 1000

points = objct(points,A,f,n_points,X[0],X[1],X[2])



# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points, 10000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

"""## Model planets"""

n = 2 # for Earth

print(np.log(eT[n]))
print(np.log(e_orb[n]))
print(np.log(e_free[n]))

print(np.log(n_freeMG[n]))
print(np.log(n_freeTH[n]))

print(np.log(Volume[n]))

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason

points = [0]

# Earth
n=2

# Magnetic electrons

A = np.log(n_freeMG[n]/e_orb[n])/10
f = np.log(n_freeMG[n])
X = [0,0,0]
n_points = 1000

points = objct(points,A,f,n_points,X[0],X[1],X[2])


# Thermal electrons

A = np.log(n_freeTH[n]/e_orb[n])/10
f = np.log(n_freeTH[n])
X = [0,0,0]
n_points = 1000

points = objct(points,A,f,n_points,X[0],X[1],X[2])


# Orbital electrons

A = 1
f = np.log(e_orb[n])
X = [0,0,0]
n_points = 1000

points = objct(points,A,f,n_points,X[0],X[1],X[2])





# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points, 10000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason

points = [0]

# Sun
n=9

# Magnetic electrons

A = np.log(n_freeMG[n])
f = np.log(n_freeMG[n])
X = [0,0,0]
n_points = 1000

points = objct(points,A,f,n_points,X[0],X[1],X[2])


# Thermal electrons

A = np.log(n_freeTH[n])
f = np.log(n_freeTH[n])
X = [0,0,0]
n_points = 1000

points = objct(points,A,f,n_points,X[0],X[1],X[2])


# Orbital electrons

A = np.log(e_orb[n])
f = np.log(e_orb[n])
X = [0,0,0]
n_points = 1000

points = objct(points,A,f,n_points,X[0],X[1],X[2])


# Earth
n=2

# Magnetic electrons

A = np.log(n_freeMG[n])
f = np.log(n_freeMG[n])
X = [1000*Sun_distance[n],0,0]
n_points = 1000

points = objct(points,A,f,n_points,X[0],X[1],X[2])


# Thermal electrons

A = np.log(n_freeTH[n])
f = np.log(n_freeTH[n])
n_points = 1000

points = objct(points,A,f,n_points,X[0],X[1],X[2])


# Orbital electrons

A = np.log(e_orb[n])
f = np.log(e_orb[n])
n_points = 1000

points = objct(points,A,f,n_points,X[0],X[1],X[2])


# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points, 10000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

"""## Forces"""

def objct(points,A,f,n_points,X,Y,Z,object_force):

  T = 1/f
  # Horizontal ring


  theta = np.linspace(-np.pi, np.pi, n_points)
  z = np.linspace(0, 0, n_points)
  r = (np.sin(f*theta))+(np.sin(f*theta)) + object_force
  x = r * np.sin(theta)*A-A/(2*np.pi*f)**(f-1)
  y = r * np.cos(theta)*A
  if len(points) == 1:
    points = np.column_stack((x+X, y+Y, z+Z))
  else:
    points = np.concatenate((points,np.column_stack((x+X, y+Y, z+Z))))
    

  # Vertical ring

  theta = np.linspace(-np.pi, np.pi, n_points)
  r = np.sin(f*theta)+np.sin(f*theta)
  z = r * np.cos(theta) 
  x = A * r * np.sin(theta)
  y = A * np.linspace(0, 0, n_points)
  points = np.concatenate((points,np.column_stack((x+X, y+Y, z+Z))))


  theta = np.linspace(-np.pi, np.pi, n_points)
  r = np.sin(f*theta)+np.sin(f*theta)
  z = r * np.cos(theta) 
  x = A * r * np.sin(theta)
  y = A * np.linspace(0, 0, n_points)
  points = np.concatenate((points,np.column_stack((x+X, y+Y, z+Z))))

  import scipy

  rotation_degrees = 90
  rotation_radians = np.radians(rotation_degrees)
  rotation_axis = np.array([0, 0, 1])

  rotation_vector = rotation_radians * rotation_axis
  rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
  rotated_vec = rotation.apply(np.column_stack((x, y, z)))
  rotated_vec[:,0] = rotated_vec[:,0] + X  # xaxis
  rotated_vec[:,1] = rotated_vec[:,1] + Y  # yaxis
  rotated_vec[:,2] = rotated_vec[:,2] + Z  # zaxis
  points = np.concatenate((points,rotated_vec))

  return points

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason

n_points = 100
points = [0]
theta = np.linspace(-np.pi, np.pi, n_points)

X2 = [2,1,0]
X1 = [8,10,0]

angle = np.arctan((X2[1]-X1[1])/(X2[0]-X1[0]))
if X2[0] == X1[0]:
  angle = 0

print(sum(X2))

a = 0
if X2[0]<X1[0]:
  a = 1

# object

A = 2
f = 10

n_points = 100

force12 = np.sin(theta+angle+a*np.pi)

points = objct(points,A,f,n_points,X1[0],X1[1],X1[2],force12)


# object

A = 2
f = 20

n_points = 100
force21 = np.sin(theta+angle+(1-a)*np.pi)

points = objct(points,A,f,n_points,X2[0],X2[1],X2[2],force21)



# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points, 10000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

"""## Planets with forces"""

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason

points = [0]

X1 = [0,0,0]
X2 = [25000*Sun_distance[n],0,0]

charge = e_orb[2]*e_orb[9]*(1.6E-19)**2
distance = np.sqrt((X2[0]-X1[0])**2+(X2[1]-X1[1])**2+(X2[2]-X1[2])**2)/1000
F = np.log(8.9875517923E9*charge/distance**2)

print(F)

angle = np.arctan((X2[1]-X1[1])/(X2[0]-X1[0]))
if X2[0] == X1[0]:
  angle = 0

a = 0
if X2[0]<X1[0]:
  a = 1

# Sun
n=9

# Magnetic electrons

A = np.log(n_freeMG[n])
f = np.log(n_freeMG[n])
X = X1
n_points = 100

force12 = F*np.sin(theta+angle+a*np.pi)

points = objct(points,A,f,n_points,X[0],X[1],X[2],force12)


# Thermal electrons

A = np.log(n_freeTH[n])
f = np.log(n_freeTH[n])
n_points = 100

points = objct(points,A,f,n_points,X[0],X[1],X[2],force12)


# Orbital electrons

A = np.log(e_orb[n])
f = np.log(e_orb[n])
n_points = 100

points = objct(points,A,f,n_points,X[0],X[1],X[2],force12)


# Earth
n=2

# Magnetic electrons

A = np.log(n_freeMG[n])
f = np.log(n_freeMG[n])
X = X2
n_points = 100

force21 = F*np.sin(theta+angle+(1-a)*np.pi)

points = objct(points,A,f,n_points,X[0],X[1],X[2],force21)


# Thermal electrons

A = np.log(n_freeTH[n])
f = np.log(n_freeTH[n])
n_points = 100

points = objct(points,A,f,n_points,X[0],X[1],X[2],force21)


# Orbital electrons

A = np.log(e_orb[n])
f = np.log(e_orb[n])
n_points = 100

points = objct(points,A,f,n_points,X[0],X[1],X[2],force21)


# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points, 10000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=10*5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

n = 2 # for Earth

print(np.log(eT[n]))
print(np.log(e_orb[n]))
print(np.log(e_free[n]))

print(np.log(n_freeMG[n]))
print(np.log(n_freeTH[n]))

print(np.log(Volume[n]))

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason

points = [0]

X1 = [0,0,0]
X2 = [1000*Sun_distance[n],0,0]

charge = e_orb[2]*e_orb[9]*(1.6E-19)**2
distance = np.sqrt((X2[0]-X1[0])**2+(X2[1]-X1[1])**2+(X2[2]-X1[2])**2)
F = np.log(8.9875517923E9*charge/distance**2)

angle = np.arctan((X2[1]-X1[1])/(X2[0]-X1[0]))
if X2[0] == X1[0]:
  angle = 0

a = 0
if X2[0]<X1[0]:
  a = 1

# Sun
n=9

# Magnetic electrons

A = np.log(n_freeMG[n])
f = np.log(n_freeMG[n])
X = X1
n_points = 100

force12 = F*np.sin(theta+angle+a*np.pi)

points = objct(points,A,f,n_points,X[0],X[1],X[2],force12)


# Thermal electrons

A = np.log(n_freeTH[n])
f = np.log(n_freeTH[n])
n_points = 100

points = objct(points,A,f,n_points,X[0],X[1],X[2],force12)


# Orbital electrons

A = np.log(e_orb[n])
f = np.log(e_orb[n])
n_points = 100

points = objct(points,A,f,n_points,X[0],X[1],X[2],force12)


# Earth
n=2

# Magnetic electrons

A = np.log(n_freeMG[n])
f = np.log(n_freeMG[n])
X = X2
n_points = 100

force21 = F*np.sin(theta+angle+(1-a)*np.pi)

points = objct(points,A,f,n_points,X[0],X[1],X[2],force21)


# Thermal electrons

A = np.log(n_freeTH[n])
f = np.log(n_freeTH[n])
n_points = 100

points = objct(points,A,f,n_points,X[0],X[1],X[2],force21)


# Orbital electrons

A = np.log(e_orb[n])
f = np.log(e_orb[n])
n_points = 100

points = objct(points,A,f,n_points,X[0],X[1],X[2],force21)


# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points, 10000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

"""## Particles"""

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 20
f = 40

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (np.sin(f*theta))+(np.sin(f*theta))
x = r * np.sin(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * np.cos(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))



# object 2

A = 1/20
f = 20

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (np.sin(f*theta))+(np.sin(f*theta))
x = r * np.sin(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * np.cos(theta)*A
points = np.concatenate((points,np.column_stack((x, y, z))))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))


# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 20
f = 40

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (np.sin(f*theta))+(np.sin(f*theta))
x = r * np.sin(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * np.cos(theta)*A
points = np.column_stack((x+2*A, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))



# object 2

A = 1/20
f = 20

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (np.sin(f*theta))+(np.sin(f*theta))
x = r * np.sin(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * np.cos(theta)*A
points = np.concatenate((points,np.column_stack((x, y, z))))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))


# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 20
f = 10

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (np.sin(f*theta))+(np.sin(f*theta))
x = r * np.sin(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * np.cos(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))



# object 2

A = 1/20
f = 20

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (np.sin(f*theta))+(np.sin(f*theta))
x = r * np.sin(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * np.cos(theta)*A
points = np.concatenate((points,np.column_stack((x, y, z))))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))


# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

"""## Curved Line"""

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason

A = 1
f = 99

T = 1/f

# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (np.sin(f*theta))+(np.sin(f*theta))
x = r * np.sin(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * np.cos(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x+A, y, z))) # changes to line by translation of A


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))

# Create spline with 1000 interpolation points
spline = pv.Spline(points, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason

A = 9
f = 99

T = 1/f

# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (np.sin(f*theta))+(np.sin(f*theta))
x = r * np.sin(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * np.cos(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x-A, y, z))) # changes to line


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))



# Create spline with 1000 interpolation points
spline = pv.Spline(points, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

"""# Fibonacci

## Fibonacci sequence
"""

def fibonacci_of(n):
  if n in {0, 1}:  # Base case
    return n
  return fibonacci_of(n - 1) + fibonacci_of(n - 2)  # Recursive case

x = [fibonacci_of(n) for n in range(15)]

plt.plot(x)


x2 = np.linspace(-1, 15, 15)
y2 = np.exp(x)

plt.figure()
plt.plot(x2, y2)

x

#0,1
fib2 = np.array([0,1,1, 2, 3, 5, 8, 13, 21, 34,55,89,144,233,377,610])

a = [0,1,1]
f = 2
n = 2

a = np.append(a,2*a[n]-(a[n-f+1]-a[n-f]))
a

#0,1,2
fib3 = np.array([0,1,2,3, 6, 11, 20, 37, 68,85,153,  306, 544, 1003,1853,3400])

#0,1,2
fib10 = np.array([0,1,2,3,4,5,6,7,8,9,10,55,109,217])

a = fib10
f = 10
n = 13

2*a[n]-(a[n-f+1]-a[n-f]) # = a[n+1]

"""## Fibonacci via machine learning"""

# predict
def pred(x):
  return reg.predict(np.array([x]))

import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression
import matplotlib as plt

# features
fibonacci = pd.DataFrame([[1,1,2],[2,1,3],[3,2,5],[5,3,8],[8,5,13]])

# target
fibonacci.columns = [0,1,2]
fibonacci.iloc[0]
fibonacci

# train
reg = LinearRegression().fit(fibonacci[[0,1]],fibonacci[2])
reg.score(fibonacci[[0,1]],fibonacci[2])

list1 = [0,1]

for k in range(1000):
  list1.append(int(np.rint(pred([list1[k],list1[k+1]]))))
print(list1)

plt.pyplot.polar(list1)

import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression
import matplotlib as plt

n = 950
# features
fibonacci = pd.DataFrame([np.transpose(list1[n+0:n+10]),np.transpose(list1[n+10:n+20]),np.transpose(list1[n+10:n+20]),np.transpose(list1[n+20:n+30]),np.transpose(list1[n+40:n+50])])

# columns
fibonacci.columns = np.linspace(0,len(list1[0:10])-1,len(list1[0:10]))
fibonacci.iloc[0]
fibonacci

# train
reg = LinearRegression().fit(fibonacci[[0,1]],fibonacci[2])
reg.score(fibonacci[[0,1]],fibonacci[2])

list1 = [0,1]

for k in range(10):
  list1.append(int(np.rint(pred([list1[k],list1[k+1]]))))

print(list1)
plt.pyplot.polar(list1);

"""# Fractals"""

def plot_coords(coords, bare_plot=False):
    if bare_plot:
        # Turns off the axis markers.
        plt.axis('off')
    # Ensures equal aspect ratio.
    plt.axes().set_aspect('equal', 'datalim')
    # Converts a list of coordinates into 
    # lists of X and Y values, respectively.
    X, Y = zip(*coords)
    # Draws the plot.
    plt.plot(X, Y);

def turtle_to_coords(turtle_program, turn_amount=45):
    # The state variable tracks the current location and angle of the turtle.
    # The turtle starts at (0, 0) facing up (90 degrees).
    state = (0.0, 0.0, 90.0)
    
    # Throughout the turtle's journey, we "yield" its location. These coordinate
    # pairs become the path that plot_coords draws.
    yield (0.0, 0.0)
    
    # Loop over the program, one character at a time.
    for command in turtle_program:
        x, y, angle = state
        
        if command in 'Ff':      # Move turtle forward
            state = (x - cos(angle * DEGREES_TO_RADIANS),
                     y + sin(angle * DEGREES_TO_RADIANS),
                     angle)
            
            if command == 'f':
                # Insert a break in the path so that
                # this line segment isn't drawn.
                yield (float('nan'), float('nan'))
                
            yield (state[0], state[1])
                        
        elif command == '+':     # Turn turtle clockwise without moving
            state = (x, y, angle + turn_amount)
            
        elif command == '-':     # Turn turtle counter-clockwise without moving
            state = (x, y, angle - turn_amount)
            
        # Note: We silently ignore unknown commands

from math import isnan
def print_coords(coords):
    for (x, y) in coords:
        if isnan(x):
            print('<gap>')
        else:
            print('({:.2f}, {:.2f})'.format(x, y))

def transform_sequence(sequence, transformations):
    return ''.join(transformations.get(c, c) for c in sequence)

def transform_multiple(sequence, transformations, iterations):
    for _ in range(iterations):
        sequence = transform_sequence(sequence, transformations)
    return sequence

def branching_turtle_to_coords(turtle_program, turn_amount=45):
    saved_states = list()
    state = (0, 0, 90)
    yield (0, 0)

    for command in turtle_program:
        x, y, angle = state

        if command.lower() in 'abcdefghij':        # Move forward (matches a-j and A-J)
            state = (x - cos(angle * DEGREES_TO_RADIANS),
                     y + sin(angle * DEGREES_TO_RADIANS),
                     angle)
            
            if command.islower():                  # Add a break in the line if command matches a-j
                yield (float('nan'), float('nan'))

            yield (state[0], state[1])

        elif command == '+':                       # Turn clockwise
            state = (x, y, angle + turn_amount)

        elif command == '-':                       # Turn counterclockwise
            state = (x, y, angle - turn_amount)

        elif command == '[':                       # Remember current state
            saved_states.append(state)

        elif command == ']':                       # Return to previous state
            state = saved_states.pop()
            yield (float('nan'), float('nan'))
            x, y, _ = state
            yield (x, y)

        # Note: We silently ignore unknown commands

def l_plot(axiom, transformations, iterations=0, angle=45):
    turtle_program = transform_multiple(axiom, transformations, iterations)
    coords = branching_turtle_to_coords(turtle_program, angle)
    plot_coords(coords, bare_plot=True) # bare_plot removes the axis labels

import matplotlib.pyplot as plt

plot_coords(turtle_to_coords(transform_multiple('F', {'F': '+F+F--F+F'}, 5)))

l_plot('F', {'F': 'FF[++F][-FF]'}, 5, 22)

l_plot('A', {'F': 'FF', 'A': 'F[+AF-[A]--A][---A]'}, 5, 22.5)

"""# Mathematics of Life"""

import numpy as np
import matplotlib.pyplot as plt

L = 100000  # length
W = 10000  # width/height/amplitude
f = 100 # frequency


x = np.linspace(0j, 5j, L)

y = W*np.exp(f*np.pi*x)
y
plt.plot(y)

L = 50  # length
W = 50  # width/height/amplitude
f = 1*L*W # frequency


i = np.linspace(0j, 1j, L)

y = W*np.exp(f*np.pi*x)
y
plt.plot(y)


# Observers view
plt.xlim(-5,105)
plt.ylim(-100,100)

L = 100  # length
W = 50000 # width/height/amplitude
f = 5 # frequency


x = np.linspace(0j, 1j, L)

y = W*np.exp(2*f*np.pi*x)
y
plt.plot(y)

L = 10000  # length
W = 500 # width/height/amplitude
f = 10000 # frequency


x = np.linspace(0j, 1j, L)

y = W*np.exp(f*np.pi*x)
y
plt.plot(np.sin(y))

"""## Cos and sine wave"""

L=1000
W=1
f=1

x = np.linspace(0j,1j,L)

xr = np.linspace(0,1,L)

y = (W*np.exp(2*f*np.pi*x))   # cos

plt.plot(xr,y)

L=1000
W=1
f=2

x = np.linspace(0j,1j,L)

xr = np.linspace(0,1,L)

y = (W*np.exp(2*f*np.pi*x-np.pi*0.5j))   # sine

plt.plot(xr,y)

"""## Normal distribution"""

mu = 1
sig = 5

L=1000
W=1/(2*np.sqrt(2*np.pi)*sig)
f=1/2

xr = np.linspace(-sig/2,sig/2,L)+mu

y = W*((-1)**(sig+1)*np.exp(-2j*f*np.pi*(xr)/sig)**2+1)  # change to real by removing -j

plt.plot(xr,y)

"""## Electromagnetism spectrum"""

L=10000
W=1
f=1

x = np.linspace(0j,1j,L)

xr = np.linspace(0,1,L)

y = np.sin(W*np.exp(2*f*np.pi*x))

y = np.sin(W*np.exp(2*f*np.pi*xr))

plt.plot(xr,y)

L=10000
W=1
f=1

x = np.linspace(0j,1j,L)

xr = np.linspace(0,1,L)

y = np.sin(W*np.exp(2*f*np.pi*x))

y = np.sin(W*np.exp(2*f*np.pi*xr))

y = W*np.exp(2j*f*np.pi*(W*np.exp(2*f*np.pi*xr))-0.5j)

plt.plot(xr,y)

"""## Heart beat"""

L = 1000000   # length
W = 14 # width/height/amplitude
f = 2 # frequency

x = np.linspace(0j, 1j, L)

y = np.sin(W*np.exp(f*np.pi*x))

plt.plot(y)

L = 1000   # length
W = 1 # width/height/amplitude
f = 2 # frequency

x = np.linspace(0j, 1j, L)
xr = np.linspace(0, 1, L)

y = W*np.exp(2*f*np.pi*(W*np.exp(2*f*np.pi*x))*1j-0.5j)

plt.plot(y)

L = 1000000  # length
W = 3 # width/height/amplitude
f = 1 # frequency

x = np.linspace(0j, 1j, L)

y = W*np.exp(2*f*np.pi*(W*np.exp(2*f*np.pi*x))*1j)

plt.plot(y)

"""## Sinusodial exponentially-corrected formulas"""

import numpy as np
import matplotlib.pyplot as plt

def E(x):
  return W*np.exp(2*f*np.pi*x)

def E2(x):
  return W*np.exp(2*f*np.pi*x-0.5j*np.pi)

def S(x):
  return W*np.exp(2*f*np.pi*x*1j-np.pi*0.5j)

def C(x):
  return W*np.exp(2*f*np.pi*x*1j)

def Electromagnetism(x):
  return S(E(x))

def ElectronWave(x):
  return C(C(x))

def LifeWave(x):
  return S(C(x))

W = 1
f = 2
L = 100000

x = np.linspace(0, 1, L)

#plt.plot(E(x)) # exponential
#plt.plot(C(x)) # cos
#plt.plot(S(x)) # sine

plt.plot(S(E(x))) # electromagnetic spectrum

#plt.plot(C(C(x))) # electron beat

plt.plot(S(C(x))) # heart beat

plt.plot(E(x))
plt.plot(E2(x))

plt.plot(E(x*1j))
plt.plot(E2(x*1j))

plt.plot(S(x))
plt.plot(C(x))

plt.plot(S(E(x)))

plt.plot(LifeWave(x))

plt.plot(ElectronWave(x))

plt.plot(Electromagnetism(x))

plt.plot(S(E(x))+C(E(x)))

plt.plot(LifeWave(x))

"""# Infinite universes"""

import numpy as np
import matplotlib.pyplot as plt

def E(x):
  return W*np.exp(2*f*np.pi*x)

def E2(x):
  return W*np.exp(2*f*np.pi*x-0.5j*np.pi)

def S(x):
  return W*np.exp(2*f*np.pi*x*1j-np.pi*0.5j)

def C(x):
  return W*np.exp(2*f*np.pi*x*1j)

def Electromagnetism(x):
  return S(E(x))

def ElectronWave(x):
  return C(C(x))

def LifeWave(x):
  return S(C(x))

W = 1
f = 100
L = 10000

x = np.linspace(0, 1, L)

phase = -0/(4*f)

fig, axs = plt.subplots(3, 2)

axs[0,0].plot(E(x+phase)) # exponential
axs[1,1].plot(C(x+phase)) # cos
axs[1,0].plot(S(x+phase)) # sine

axs[0,1].plot(S(E(x+phase))) # electromagnetic spectrum

axs[2,1].plot(C(C(x+phase))) # electron beat
axs[2,0].plot(S(C(x+phase))) # heart beat

W = 25
f = 25
L = 10000

x = np.linspace(0, 1, L)

phase = -0/(4*f)

fig, axs = plt.subplots(3, 2)

axs[0,0].plot(E(x+phase)) # exponential
axs[1,1].plot(C(x+phase)) # cos
axs[1,0].plot(S(x+phase)) # sine

axs[0,1].plot(S(E(x+phase))) # electromagnetic spectrum

axs[2,1].plot(C(C(x+phase))) # electron beat
axs[2,0].plot(S(C(x+phase))) # heart beat

W = 2
f = 50
L = 10000

x = np.linspace(0, 1, L)

phase = -0/(4*f)

fig, axs = plt.subplots(3, 2)

axs[0,0].plot(E(x+phase)) # exponential
axs[1,1].plot(C(x+phase)) # cos
axs[1,0].plot(S(x+phase)) # sine

axs[0,1].plot(S(E(x+phase))) # electromagnetic spectrum

axs[2,1].plot(C(C(x+phase))) # electron beat
axs[2,0].plot(S(C(x+phase))) # heart beat

# W x f < 100

W = 25
f = 3
L = 10000

x = np.linspace(0, 1, L)

phase = -0/(4*f)

fig, axs = plt.subplots(3, 2)

axs[0,0].plot(E(x+phase)) # exponential
axs[1,1].plot(C(x+phase)) # cos
axs[1,0].plot(S(x+phase)) # sine

axs[0,1].plot(S(E(x+phase))) # electromagnetic spectrum

axs[2,1].plot(C(C(x+phase))) # electron beat
axs[2,0].plot(S(C(x+phase))) # heart beat

W = 50
f = 25
L = 10000

x = np.linspace(0, 1, L)

phase = -0/(4*f)

fig, axs = plt.subplots(3, 2)

axs[0,0].plot(E(x+phase)) # exponential
axs[1,1].plot(C(x+phase)) # cos
axs[1,0].plot(S(x+phase)) # sine

axs[0,1].plot(S(E(x+phase))) # electromagnetic spectrum

axs[2,1].plot(C(C(x+phase))) # electron beat
axs[2,0].plot(S(C(x+phase))) # heart beat

W = 75
f = 25
L = 10000

x = np.linspace(0, 1, L)

phase = -0/(4*f)

fig, axs = plt.subplots(3, 2)

axs[0,0].plot(E(x+phase)) # exponential
axs[1,1].plot(C(x+phase)) # cos
axs[1,0].plot(S(x+phase)) # sine

axs[0,1].plot(S(E(x+phase))) # electromagnetic spectrum

axs[2,1].plot(C(C(x+phase))) # electron beat
axs[2,0].plot(S(C(x+phase))) # heart beat

W = 1/2
f = 4
L = 10000

x = np.linspace(0, 1, L)

phase = -0/(4*f)

fig, axs = plt.subplots(3, 2)

axs[0,0].plot(E(x+phase)) # exponential
axs[1,1].plot(C(x+phase)) # cos
axs[1,0].plot(S(x+phase)) # sine

axs[0,1].plot(S(E(x+phase))) # electromagnetic spectrum

axs[2,1].plot(C(C(x+phase))) # electron beat
axs[2,0].plot(S(C(x+phase))) # heart beat



"""# Exponential quantum relativity

## Initialise
"""

import numpy as np
import matplotlib.pyplot as plt

def factorial(x):
  factorial = 1
  if int(x) >= 1:
    for i in range (1,int(x)+1):
      factorial = factorial * i
  return factorial

def exp(x,n):
  exp = 0
  for i in range (0,n):
    exp += (1/factorial(i))
  return exp**x

n = 100

def E(x,n):
  return W*exp(2*f*np.pi*x,n)

def E2(x,n):
  return W*exp(2*f*np.pi*x-0.5j*np.pi,n)

def S(x):
  return W*exp(2*f*np.pi*x*1j-np.pi*0.5j,n)

def C(x):
  return W*exp(2*f*np.pi*x*1j,n)

def Electromagnetism(x):
  return S(E(x))

def ElectronWave(x):
  return C(C(x))

def LifeWave(x):
  return S(C(x))

W = 10 # 1/1000 Volumatic # 10 lines # 25 particles # 1 normal
f = 10
L = 1000

# x = np.linspace(0, 1, L)
# w1/10, f1/10 (Default/volume)
# w1, f1 (Default/string)
# w5, f5 (Default/particles)

# w1,f100 (DNA)
# w25,f25,f100 (Particles)
# w10,f10,f99 (Particles/Lines)
# w 1/1000,f1, f25 (Volumes)

# w1, f1/(2*np.pi) x = np.linspace(np.pi/2, 5*np.pi/2, L)

x = np.linspace(0, 1, L)
x = np.linspace(np.pi/2, 5*np.pi/2, L)

phase = -0/(4*f)

fig, axs = plt.subplots(3, 2)

axs[0,0].plot(E(x+phase,n)) # exponential
axs[1,1].plot(C(x+phase)) # cos
axs[1,0].plot(S(x+phase)) # sine

axs[0,1].plot(S(E(x+phase,n))) # electromagnetic spectrum

axs[2,1].plot(C(C(x+phase))) # electron beat
axs[2,0].plot(S(C(x+phase))) # heart beat

"""## Sphere"""

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 1
f = 2

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (S(f*theta))+(S(f*theta))
x = r * S(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * C(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))





import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))






# Create spline with 1000 interpolation points
spline = pv.Spline(points.real, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 1
f = 99

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (S(f*theta))+(S(f*theta))
x = r * S(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * C(theta)*A
points = np.column_stack((x, y, z))




# Create spline with 1000 interpolation points
spline = pv.Spline(points.real, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 1
f = 5

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (S(f*theta))+(S(f*theta))
x = r * S(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * C(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))






# Create spline with 1000 interpolation points
spline = pv.Spline(points.real, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 1/10
f = 100

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (S(f*theta))+(S(f*theta))
x = r * S(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * C(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



# Create spline with 1000 interpolation points
spline = pv.Spline(points.real, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 1/2
f = 2

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (S(f*theta))+(S(f*theta))
x = r * S(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * C(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



# Create spline with 1000 interpolation points
spline = pv.Spline(points.real, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 1/10
f = 10

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (S(f*theta))+(S(f*theta))
x = r * S(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * C(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



# Create spline with 1000 interpolation points
spline = pv.Spline(points.real, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 1/10
f = 10

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (S(f*theta))+(S(f*theta))
x = r * S(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * C(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



# Create spline with 1000 interpolation points
spline = pv.Spline(points.real, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

"""## Rings

### Real
"""

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 1
f = 1

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (S(f*theta))+(S(f*theta))
x = r * S(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * C(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))



# Create spline with 1000 interpolation points
spline = pv.Spline(points.real, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 1
f = 25

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (S(f*theta))+(S(f*theta))
x = r * S(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * C(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))



# Create spline with 1000 interpolation points
spline = pv.Spline(points.real, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 10
f = 20

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (S(f*theta))+(S(f*theta))
x = r * S(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * C(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))



# Create spline with 1000 interpolation points
spline = pv.Spline(points.real, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

"""### Imaginary"""

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 1
f = 1

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (S(f*theta))+(S(f*theta))
x = r * S(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * C(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))






# Create spline with 1000 interpolation points
spline = pv.Spline(points.imag, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 1
f = 25

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (S(f*theta))+(S(f*theta))
x = r * S(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * C(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))



# Create spline with 1000 interpolation points
spline = pv.Spline(points.imag, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

"""## Two relative models"""

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 2
f = 2

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (S(f*theta))+(S(f*theta))
x = r * S(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * C(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))



# object 2

A = 1/2
f = 2

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (S(f*theta))+(S(f*theta))
x = r * S(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * C(theta)*A
points = np.concatenate((points,np.column_stack((x, y, z))))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))


# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points.real, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

"""## Object"""

def objct2(points,A,f,n_points,X,Y,Z):

  T = 1/f
  # Horizontal ring


  theta = np.linspace(-np.pi, np.pi, n_points)
  z = np.linspace(0, 0, n_points)
  r = (S(f*theta))+(S(f*theta))
  x = r * S(theta)*A-A/(2*np.pi*f)**(f-1)
  y = r * C(theta)*A
  if len(points) == 1:
    points = np.column_stack((x+X, y+Y, z+Z))
  else:
    points = np.concatenate((points,np.column_stack((x+X, y+Y, z+Z))))
    

  # Vertical ring

  theta = np.linspace(-np.pi, np.pi, n_points)
  r = S(f*theta)+S(f*theta)
  z = r * C(theta) 
  x = A * r * S(theta)
  y = A * np.linspace(0, 0, n_points)
  points = np.concatenate((points,np.column_stack((x+X, y+Y, z+Z))))


  theta = np.linspace(-np.pi, np.pi, n_points)
  r = S(f*theta)+S(f*theta)
  z = r * C(theta) 
  x = A * r * S(theta)
  y = A * np.linspace(0, 0, n_points)
  points = np.concatenate((points,np.column_stack((x+X, y+Y, z+Z))))

  import scipy

  rotation_degrees = 90
  rotation_radians = np.radians(rotation_degrees)
  rotation_axis = np.array([0, 0, 1])

  rotation_vector = rotation_radians * rotation_axis
  rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
  rotated_vec = rotation.apply(np.column_stack((x, y, z)))
  rotated_vec[:,0] = rotated_vec[:,0] + X  # xaxis
  rotated_vec[:,1] = rotated_vec[:,1] + Y  # yaxis
  rotated_vec[:,2] = rotated_vec[:,2] + Z  # zaxis
  points = np.concatenate((points,rotated_vec))

  return points

"""## Modelling"""

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 2
f = 2
n_points = 400

points = [0]

points = objct2(points,A,f,n_points,0,0,0)



# object 2

A = 1/10
f = 20
X = [10,0,3]
n_points = 100

points = objct2(points,A,f,n_points,X[0],X[1],X[2])


# object 3

A = 1/100
f = 10
X = [20,5,3]
n_points = 100

points = objct2(points,A,f,n_points,X[0],X[1],X[2])


# object 4

A = 5
f = 90
X = [25,5,-10]
n_points = 100

points = objct2(points,A,f,n_points,X[0],X[1],X[2])


# object 5

A = 2
f = 20
X = [15,15,-10]
n_points = 100

points = objct2(points,A,f,n_points,X[0],X[1],X[2])


# object 6

A = 2
f = 50
X = [15,30,6]
n_points = 100

points = objct2(points,A,f,n_points,X[0],X[1],X[2])


# object 6

A = 1/2
f = 10
X = [15,30,10]
n_points = 100

points = objct2(points,A,f,n_points,X[0],X[1],X[2])


# object 6

A = 2
f = 20
X = [15,30,10]
n_points = 100

points = objct2(points,A,f,n_points,X[0],X[1],X[2])



# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points.real, 10000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

"""## Model planets"""

n = 2 # for Earth

print(np.log(eT[n]))
print(np.log(e_orb[n]))
print(np.log(e_free[n]))

print(np.log(n_freeMG[n]))
print(np.log(n_freeTH[n]))

print(np.log(Volume[n]))

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason

points = [0]

# Earth
n=2

# Magnetic electrons

A = np.log(n_freeMG[n]/e_orb[n])/10
f = np.log(n_freeMG[n])
X = [0,0,0]
n_points = 1000

points = objct2(points,A,f,n_points,X[0],X[1],X[2])


# Thermal electrons

A = np.log(n_freeTH[n]/e_orb[n])/10
f = np.log(n_freeTH[n])
X = [0,0,0]
n_points = 1000

points = objct2(points,A,f,n_points,X[0],X[1],X[2])


# Orbital electrons

A = 1
f = np.log(e_orb[n])
X = [0,0,0]
n_points = 1000

points = objct2(points,A,f,n_points,X[0],X[1],X[2])





# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points.imag, 10000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason

points = [0]

# Sun
n=9

# Magnetic electrons

A = np.log(n_freeMG[n])
f = np.log(n_freeMG[n])
X = [0,0,0]
n_points = 1000

points = objct2(points,A,f,n_points,X[0],X[1],X[2])


# Thermal electrons

A = np.log(n_freeTH[n])
f = np.log(n_freeTH[n])
X = [0,0,0]
n_points = 1000

points = objct2(points,A,f,n_points,X[0],X[1],X[2])


# Orbital electrons

A = np.log(e_orb[n])
f = np.log(e_orb[n])
X = [0,0,0]
n_points = 1000

points = objct2(points,A,f,n_points,X[0],X[1],X[2])


# Earth
n=2

# Magnetic electrons

A = np.log(n_freeMG[n])
f = np.log(n_freeMG[n])
X = [10000*Sun_distance[n],0,0]
n_points = 1000

points = objct2(points,A,f,n_points,X[0],X[1],X[2])


# Thermal electrons

A = np.log(n_freeTH[n])
f = np.log(n_freeTH[n])
n_points = 1000

points = objct2(points,A,f,n_points,X[0],X[1],X[2])


# Orbital electrons

A = np.log(e_orb[n])
f = np.log(e_orb[n])
n_points = 1000

points = objct2(points,A,f,n_points,X[0],X[1],X[2])


# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points.real, 10000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

"""## Forces"""

def objct2(points,A,f,n_points,X,Y,Z,object_force):

  T = 1/f
  # Horizontal ring


  theta = np.linspace(-np.pi, np.pi, n_points)
  z = np.linspace(0, 0, n_points)
  r = (S(f*theta))+(S(f*theta)) + object_force
  x = r * S(theta)*A-A/(2*np.pi*f)**(f-1)
  y = r * C(theta)*A
  if len(points) == 1:
    points = np.column_stack((x+X, y+Y, z+Z))
  else:
    points = np.concatenate((points,np.column_stack((x+X, y+Y, z+Z))))
    

  # Vertical ring

  theta = np.linspace(-np.pi, np.pi, n_points)
  r = S(f*theta)+S(f*theta)
  z = r * C(theta) 
  x = A * r * S(theta)
  y = A * np.linspace(0, 0, n_points)
  points = np.concatenate((points,np.column_stack((x+X, y+Y, z+Z))))


  theta = np.linspace(-np.pi, np.pi, n_points)
  r = S(f*theta)+S(f*theta)
  z = r * C(theta) 
  x = A * r * S(theta)
  y = A * np.linspace(0, 0, n_points)
  points = np.concatenate((points,np.column_stack((x+X, y+Y, z+Z))))

  import scipy

  rotation_degrees = 90
  rotation_radians = np.radians(rotation_degrees)
  rotation_axis = np.array([0, 0, 1])

  rotation_vector = rotation_radians * rotation_axis
  rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
  rotated_vec = rotation.apply(np.column_stack((x, y, z)))
  rotated_vec[:,0] = rotated_vec[:,0] + X  # xaxis
  rotated_vec[:,1] = rotated_vec[:,1] + Y  # yaxis
  rotated_vec[:,2] = rotated_vec[:,2] + Z  # zaxis
  points = np.concatenate((points,rotated_vec))

  return points

"""### 2 bodies"""

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason

n_points = 100
points = [0]
theta = np.linspace(-np.pi, np.pi, n_points)

X2 = [10,1,8]
X1 = [2,10,0]


if X2[0] != X1[0]:
  angle = np.arctan((X2[1]-X1[1])/(X2[0]-X1[0]))
else:
  angle = 0

print(sum(X2))

a = 0
if X2[0]<X1[0]:
  a = 1

# object

A = 2
f = 10



force12 = S(theta+angle+a*np.pi)

points = objct2(points,A,f,n_points,X1[0],X1[1],X1[2],force12)


# object

A = 2
f = 10


force21 = S(theta+angle+(1-a)*np.pi)

points = objct2(points,A,f,n_points,X2[0],X2[1],X2[2],force21)



# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points.real, 10000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

"""## Planets with forces"""

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason

points = [0]

X1 = [0,0,0]
X2 = [Sun_distance[n],0,0]

distance = np.sqrt((X2[0]-X1[0])**2+(X2[1]-X1[1])**2+(X2[2]-X1[2])**2)/1000

cm = n_freeMG[2]*n_freeMG[9]*(1.6E-19)**2
cth = n_freeTH[2]*n_freeTH[9]*(1.6E-19)**2
co = e_orb[2]*e_orb[9]*(1.6E-19)**2

Fm = np.log(8.9875517923E9*cm/distance**2)*0
Fth = np.log(8.9875517923E9*cth/distance**2)*0
Fo = np.log(8.9875517923E9*co/distance**2)


if X2[0] != X1[0]:
  angle = np.arctan((X2[1]-X1[1])/(X2[0]-X1[0]))
else:
  angle = 0

a = 0
if X2[0]<X1[0]:
  a = 1

# Sun
n=9

# Magnetic electrons

A = np.log(n_freeMG[n])
f = np.log(n_freeMG[n])
X = X1
n_points = 100

forcem12 = Fm*S(theta+angle+a*np.pi)

points = objct2(points,A,f,n_points,X[0],X[1],X[2],forcem12)


# Thermal electrons

A = np.log(n_freeTH[n])
f = np.log(n_freeTH[n])
n_points = 100

forceth12 = Fth*S(theta+angle+a*np.pi)

points = objct2(points,A,f,n_points,X[0],X[1],X[2],forceth12)


# Orbital electrons

A = np.log(e_orb[n])
f = np.log(e_orb[n])
n_points = 100

forceo12 = Fo*S(theta+angle+a*np.pi)

points = objct2(points,A,f,n_points,X[0],X[1],X[2],forceo12)


# Earth
n=2

# Magnetic electrons

A = np.log(n_freeMG[n])
f = np.log(n_freeMG[n])
X = X2
n_points = 100

forcem21 = Fm*S(theta+angle+(1-a)*np.pi)

points = objct2(points,A,f,n_points,X[0],X[1],X[2],forcem21)


# Thermal electrons

A = np.log(n_freeTH[n])
f = np.log(n_freeTH[n])
n_points = 100

forceth21 = Fth*S(theta+angle+(1-a)*np.pi)

points = objct2(points,A,f,n_points,X[0],X[1],X[2],forceth21)


# Orbital electrons

A = np.log(e_orb[n])
f = np.log(e_orb[n])
n_points = 100

forceo21 = Fo*S(theta+angle+(1-a)*np.pi)

points = objct2(points,A,f,n_points,X[0],X[1],X[2],forceo21)


# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points.real, 10000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=10*5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

n = 2 # for Earth

print(np.log(eT[n]))
print(np.log(e_orb[n]))
print(np.log(e_free[n]))

print(np.log(n_freeMG[n]))
print(np.log(n_freeTH[n]))

print(np.log(Volume[n]))

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason

points = [0]

X1 = [0,0,0]
X2 = [1000*Sun_distance[n],0,0]

charge = e_orb[2]*e_orb[9]*(1.6E-19)**2
distance = np.sqrt((X2[0]-X1[0])**2+(X2[1]-X1[1])**2+(X2[2]-X1[2])**2)
F = np.log(8.9875517923E9*charge/distance**2)

angle = np.arctan((X2[1]-X1[1])/(X2[0]-X1[0]))
if X2[0] == X1[0]:
  angle = 0

a = 0
if X2[0]<X1[0]:
  a = 1

# Sun
n=9

# Magnetic electrons

A = np.log(n_freeMG[n])
f = np.log(n_freeMG[n])
X = X1
n_points = 100

force12 = F*np.sin(theta+angle+a*np.pi)

points = objct2(points,A,f,n_points,X[0],X[1],X[2],force12)


# Thermal electrons

A = np.log(n_freeTH[n])
f = np.log(n_freeTH[n])
n_points = 100

points = objct2(points,A,f,n_points,X[0],X[1],X[2],force12)


# Orbital electrons

A = np.log(e_orb[n])
f = np.log(e_orb[n])
n_points = 100

points = objct2(points,A,f,n_points,X[0],X[1],X[2],force12)


# Earth
n=2

# Magnetic electrons

A = np.log(n_freeMG[n])
f = np.log(n_freeMG[n])
X = X2
n_points = 100

force21 = F*np.sin(theta+angle+(1-a)*np.pi)

points = objct2(points,A,f,n_points,X[0],X[1],X[2],force21)


# Thermal electrons

A = np.log(n_freeTH[n])
f = np.log(n_freeTH[n])
n_points = 100

points = objct2(points,A,f,n_points,X[0],X[1],X[2],force21)


# Orbital electrons

A = np.log(e_orb[n])
f = np.log(e_orb[n])
n_points = 100

points = objct2(points,A,f,n_points,X[0],X[1],X[2],force21)


# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points.real, 10000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

"""## Particles"""

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 20
f = 40

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (S(f*theta))+(S(f*theta))
x = r * S(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * C(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * np.cos(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))



# object 2

A = 1/20
f = 20

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (S(f*theta))+(S(f*theta))
x = r * S(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * C(theta)*A
points = np.concatenate((points,np.column_stack((x, y, z))))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))


# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points.real, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 20
f = 40

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (S(f*theta))+(S(f*theta))
x = r * S(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * C(theta)*A
points = np.column_stack((x+2*A, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * np.cos(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * C(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))



# object 2

A = 1/20
f = 20

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (S(f*theta))+(S(f*theta))
x = r * S(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * C(theta)*A
points = np.concatenate((points,np.column_stack((x, y, z))))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))


# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points.real, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason



# object 1

A = 20
f = 10

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (np.sin(f*theta))+(np.sin(f*theta))
x = r * np.sin(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * np.cos(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))



# object 2

A = 1/20
f = 20

T = 1/f


# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (np.sin(f*theta))+(np.sin(f*theta))
x = r * np.sin(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * np.cos(theta)*A
points = np.concatenate((points,np.column_stack((x, y, z))))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x, y, z)))


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))


# 3D plot

# Create spline with 1000 interpolation points
spline = pv.Spline(points, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

"""## Curved Line"""

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason

A = 1
f = 20

T = 1/f

# Horizontal ring

n_points = 100
theta = np.linspace(-1, 1, n_points)
z = np.linspace(0, 0, n_points)
r = (S(f*theta))+(S(f*theta))
x = r * S(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * C(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

#theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


#theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x+A, y, z))) # changes to line by translation of A


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = S(f*theta)+S(f*theta)
z = r * C(theta) 
x = A * r * S(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))

# Create spline with 1000 interpolation points
spline = pv.Spline(points.real, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

### new cell spline example cell ###
pn.extension('vtk')  # this needs to be at the top of each cell for some reason

A = 9
f = 99

T = 1/f

# Horizontal ring

n_points = 100
theta = np.linspace(-np.pi, np.pi, n_points)
z = np.linspace(0, 0, n_points)
r = (np.sin(f*theta))+(np.sin(f*theta))
x = r * np.sin(theta)*A-A/(2*np.pi*f)**(f-1)
y = r * np.cos(theta)*A
points = np.column_stack((x, y, z))


# Vertical ring

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))


theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,np.column_stack((x, y, z))))



import scipy

rotation_degrees = 90
rotation_radians = np.radians(rotation_degrees)
rotation_axis = np.array([0, 0, 1])

rotation_vector = rotation_radians * rotation_axis
rotation = scipy.spatial.transform.Rotation.from_rotvec(rotation_vector)
rotated_vec = rotation.apply(np.column_stack((x-A, y, z))) # changes to line


# Vertical rotated by 90
angle = np.pi/2

theta = np.linspace(-np.pi, np.pi, n_points)
r = np.sin(f*theta)+np.sin(f*theta)
z = r * np.cos(theta) 
x = A * r * np.sin(theta)
y = A * np.linspace(0, 0, n_points)
points = np.concatenate((points,rotated_vec))



# Create spline with 1000 interpolation points
spline = pv.Spline(points, 1000)

# add scalars to spline and plot it
spline["scalars"] = np.arange(spline.n_points)
tube = spline.tube(radius=5*A*0.02)
tube.plot(smooth_shading=True, notebook=True);

"""# Exponential mathematics

## Initialise
"""

import numpy as np
import matplotlib.pyplot as plt

def factorial(x):
  factorial = 1
  if int(x) >= 1:
    for i in range (1,int(x)+1):
      factorial = factorial * i
  return factorial

def exp(x,n):
  exp = 0
  for i in range (0,n):
    exp += (1/factorial(i))
  return exp**x

n = 100

def E(x,n):
  return W*exp(2*f*np.pi*x,n)

def E2(x,n):
  return W*exp(2*f*np.pi*x-0.5j*np.pi,n)

def S(x):
  return W*exp(2*f*np.pi*x*1j-np.pi*0.5j,n)

def C(x):
  return W*exp(2*f*np.pi*x*1j,n)

def Electromagnetism(x):
  return S(E(x,n))

def ElectronWave(x):
  return C(C(x))

def LifeWave(x):
  return S(C(x))

"""## C wave and S wave comparison to cos and sine"""

W = 1 # 1/1000 Volumatic # 10 lines # 25 particles # 1 normal
f = 1/(2*np.pi)
L = 10000

# w1/10, f1/10 (Default/volume)
# w1, f1 (Default/string)
# w5, f5 (Default/particles)

# w1,f100 (DNA)
# w25,f25,f100 (Particles)
# w10,f10,f99 (Particles/Lines)
# w 1/1000,f1, f25 (Volumes)


x = np.linspace(0, 2*np.pi, L)
#x = np.linspace(0, 1, L)

phase = -0/(4*f)

fig, axs = plt.subplots(3, 2)
plt.subplots_adjust(wspace=0.3, hspace=0.5)

axs[0,0].plot(x,E(x+phase,n)) # exponential
axs[1,1].plot(x,C(x+phase)) # cos
axs[1,0].plot(x,S(x+phase)) # sine

axs[0,1].plot(x,S(E(x+phase,n))) # electromagnetic spectrum

axs[2,1].plot(x,C(C(x+phase))) # electron beat
axs[2,0].plot(x,S(C(x+phase))) # heart beat

plt.plot(x,S(x))
plt.plot(x,np.sin(x))

plt.plot(x,C(x))
plt.plot(x,np.cos(x))

plt.plot(C(x)**2+S(x)**2)

plt.plot(np.cos(x)**2+np.sin(x)**2)

plt.plot(C(x)**2)
plt.plot(S(x)**2)

plt.plot(np.sin(x)**2)
plt.plot(np.cos(x)**2)

plt.plot(np.sin(x*1j))
#plt.plot(np.cos(x*1j))
#plt.plot(C(x*1j))
#plt.plot(S(x*1j))

"""## Discrete exponential increase"""

W = 1 # 1/1000 Volumatic # 10 lines # 25 particles # 1 normal
f = 100
L = 10000

# w1/10, f1/10 (Default/volume)
# w1, f1 (Default/string)
# w5, f5 (Default/particles)

# w1,f100 (DNA)
# w25,f25,f100 (Particles)
# w10,f10,f99 (Particles/Lines)
# w 1/1000,f1, f25 (Volumes)


x = np.linspace(0, 1, L)
#x = np.linspace(np.pi/2, 5*np.pi/2, L)

phase = -0/(4*f)

fig, axs = plt.subplots(3, 2)

axs[0,0].plot(x,E(x+phase,n)) # exponential
axs[1,1].plot(x,C(x+phase)) # cos
axs[1,0].plot(x,S(x+phase)) # sine

axs[0,1].plot(x,S(E(x+phase,n))) # electromagnetic spectrum

axs[2,1].plot(x,C(C(x+phase))) # electron beat
axs[2,0].plot(x,S(C(x+phase))) # heart beat

plt.plot(x,C(x)**2+S(x)**2)

"""## Comparison to ECG data

### Initiate
"""

from google.colab import drive
drive.mount('/content/drive')

#%cd /content/drive/MyDrive/Machine Learning Ideas/ECG data

# ECG data
with open("/content/drive/MyDrive/Machine Learning Ideas/Quantum Relativity/ECG data/mitbih_train.csv") as file_name:
    ecg_array = np.loadtxt(file_name, delimiter=",")

# C and S wave comparison

ecg_array

"""### Analysis"""

plt.plot(ecg_array[0,:]);

W = 1/2 # 1/1000 Volumatic # 10 lines # 25 particles # 1 normal
W2 = 0.0022

a = 1  #  stretch in x
c = 0  # elevation

f = 2.2
L = 188

x = np.linspace(0, 1, L)

phase = 0.35 #-0/(4*f)

plt.plot(x*180,W2*S(C(a*x+phase))+c, linestyle = '--', label = 'Generated'); # heart beat

plt.plot(ecg_array[0,:], label = 'ECG');

plt.legend()

W = 1/2 # 1/1000 Volumatic # 10 lines # 25 particles # 1 normal
f = 2.2 

W2 = 0.0028

a1 = 1  #  stretch in x
c1 = 0  # elevation
a2 = 0.4  #  stretch in x
c2 = 0.1  # elevation


L = 188
x = np.linspace(0, 1, L)

phase1 = 0.345 #-0/(4*f)
phase2 = 0.225 #-0/(4*f)

plt.plot(x*180,W2*S(C(a1*x+phase1))+c1, linestyle = '--', label = 'Generated'); # heart beat

W = 1/4
f = 2.2*2
plt.plot(x*180,W2*C(C(a2*x+phase2))+c2, linestyle = '--', label = 'Generated'); # electronic beat

plt.plot(ecg_array[0,:], label = 'ECG');

plt.legend()

L = 188
x = np.linspace(0, 1, L)

W = 1/2 # 1/1000 Volumatic # 10 lines # 25 particles # 1 normal
f = 2.2 

W2 = 0.0028
a1 = 1  #  stretch in x
c1 = 0  # elevation
phase1 = 0.345

beat1 = W2*S(C(a1*x+phase1))+c1

W = 1/4
f = 2.2*2

W3 = 0.0022
a2 = 0.4  #  stretch in x
c2 = 0.1  # elevation
phase2 = 0.225

beat2 = W3*C(C(a2*x+phase2))+c2


plt.plot(x*180,beat1+beat2, linestyle = '--', label = 'Generated'); # electronic beat
plt.plot(ecg_array[0,:], label = 'ECG');
plt.legend()

"""### Machine learning

#### Initialise
"""

# Machine learning to update parameters efficiently

def beat_gen_analysis(W1,W2,a,c,f1,phase,ecg):


  n = 100

  def E(x,n):
    return W*exp(2*f*np.pi*x,n)

  def E2(x,n):
    return W*exp(2*f*np.pi*x-0.5j*np.pi,n)

  def S(x):
    return W*exp(2*f*np.pi*x*1j-np.pi*0.5j,n)

  def C(x):
    return W*exp(2*f*np.pi*x*1j,n)

  def Electromagnetism(x):
    return S(E(x))

  def ElectronWave(x):
    return C(C(x))

  def LifeWave(x):
    return S(C(x))

  W = W1
  f = f1
  
  L = 188
  x = np.linspace(0, 1, L)

  #plt.plot(x*180,W2*S(C(a*x+phase))+c, linestyle = '--', label = 'Generated'); # heart beat
  #plt.plot(ecg, label = 'ECG');
  plt.legend()


  return W2*S(C(a*x+phase))+c

# Beat1

beat1 = beat_gen_analysis(0.5,0.0028,1,0,2.2,0.345,ecg_array[0,:])
                       # (W, W2,  a,c,  f,phase,ecg)


# Beat2

beat2 = beat_gen_analysis(0.25,0.0022,0.4,0.1,4.4,0.225,ecg_array[0,:])
                        # (W, W2,  a,c,  f,phase,ecg)

plt.plot(x*180,beat1+beat2, linestyle = '--', label = 'Generated');
plt.plot(ecg_array[0,:], label = 'ECG');

def heartbeat(W1, W2,  a1,c1,  f1,phase1, W12, W22,  a2,c2,  f2,phase2,ecg):
  # Beat1

  beat1 = beat_gen_analysis(W1, W2,  a1,c1,  f1,phase1,ecg)
                        # (W, W2,  a,c,  f,phase,ecg)


  # Beat2

  beat2 = beat_gen_analysis(W12, W22,  a2,c2,  f2,phase2,ecg)
                          # (W, W2,  a,c,  f,phase,ecg)

  plt.plot(x*180,beat1+beat2, linestyle = '--', label = 'Generated');
  plt.plot(ecg_array[0,:], label = 'ECG');

  return beat1+beat2

W1, W2,  a1,c1,  f1,phase1 = 0.5,0.0028,1,0,2.2,0.345
W12, W22,  a2,c2,  f2,phase2,ecg = 0.25,0.0022,0.4,0.1,4.4,0.225,ecg_array[0,:]

hbeat = heartbeat(W1, W2,  a1,c1,  f1,phase1, W12, W22,  a2,c2,  f2,phase2,ecg)
               # (W1, W2,  a1,c1,  f1,phase1, W12, W22,  a2,c2,  f2,phase2,ecg)

"""#### Variable training"""

# Beat1

W = 1/2 
f = 2.2 

beat1 = beat_gen_analysis(0.5,0.0028,1,0,2.2,0.345,ecg_array[0,:])
                       # (W, W2,  a,c,  f,phase,ecg)


# Beat2

W = 0.25
f = 4.4 

beat2 = beat_gen_analysis(0.25,0.0022,0.4,0.1,4.4,0.225,ecg_array[0,:])
                        # (W, W2,  a,c,  f,phase,ecg)

plt.plot(x*180,beat1+beat2, linestyle = '--', label = 'Generated');
plt.plot(ecg_array[0,:], label = 'ECG');

"""## Comparison to Electromagnetic spectrum"""

W = 1 # 1/1000 Volumatic # 10 lines # 25 particles # 1 normal
f = 1
L = 10000

# w1/10, f1/10 (Default/volume)
# w1, f1 (Default/string)
# w5, f5 (Default/particles)

# w1,f100 (DNA)
# w25,f25,f100 (Particles)
# w10,f10,f99 (Particles/Lines)
# w 1/1000,f1, f25 (Volumes)


x = np.linspace(0, 1, L)
#x = np.linspace(np.pi/2, 5*np.pi/2, L)

phase = -0/(4*f)

plt.plot(x,S(E(x+phase,n))) # electromagnetic spectrum

# Cos and sine comparison

# Evaluation

"""# Main equation"""

W = 1
f = 4
x = np.linspace(0,1,100)

plt.plot(x,(x))
plt.plot(x,(2*np.pi*x))
plt.plot(x,(2*np.pi*f*x))
plt.plot(x,(2*np.pi*f*x*1J))
#plt.plot(x,np.exp(2*np.pi*f*x))

x = 1
y = 1

sum = np.zeros(10000)

for K in range(1,10000):
    y *= x/K
    sum[K] = y

2*np.sum(sum)

"""## Exponential function

### Opposite
"""

def exp2(x):
  x = np.array(x)
  accuracy = 100

  y = np.ones(len(x))
  if isinstance(x[0], complex):
    y = np.ones(len(x))*1j
    
  y2 = np.zeros((accuracy,len(x)))

  for K in range(1,accuracy):
      y*= x/K
      for i in range(0,len(x)):
        y2[K,i] = np.sum(y[i],axis=0)

  return y2

plt.plot(x,np.transpose(exp2(x)));

x = np.linspace(-10,10,50)
plt.plot(x,np.transpose(exp2(1j*x)));

plt.plot(x,np.transpose(exp2(1j*x)));

f = 1

plt.plot(x,np.transpose(exp2(2*np.pi*f*x*1j)));

"""### Normal"""

accuracy = 1000

x = np.array([1])

y = np.ones(len(x))
y2 = np.zeros((accuracy,len(x)))

for K in range(1,accuracy):
    y *= x/K
    for i in range(0,len(x)):
      y2[K,i] = y[i]

np.sum(y2,axis=0)+1

def exp(x):
  x = np.array(x)
  accuracy = 1000

  y = np.ones(len(x))
  if isinstance(x[0], complex):
    y = -1j*np.ones(len(x))
    
  y2 = np.zeros((accuracy,len(x)))

  for K in range(1,accuracy):
      y *= x/K
      for i in range(0,len(x)):
        y2[K,i] = y[i]

  return np.sum(y2,axis=0)

def exp(x):
  x = np.array(x)
  accuracy = 1000

  y = np.ones(len(x))
  if isinstance(x[0], complex):
    y = np.ones(len(x))*1j
    
  y2 = np.zeros((accuracy,len(x)))

  for K in range(1,accuracy):
      y *= x/K
      for i in range(0,len(x)):
        y2[K,i] = -y[i]

  return np.sum(y2,axis=0)+1

def exp(x):
  x = np.array(x)
  accuracy = 1000

  y = np.ones(len(x))
  if isinstance(x[0], complex):
    y = np.ones(len(x))*1j
    
  y2 = np.zeros((accuracy,len(x)))

  for K in range(1,accuracy):
      y *= x/K
      for i in range(0,len(x)):
        y2[K,i] = y[i]

  return np.sum(y2,axis=0)

x = np.linspace(-10,1,100)
plt.plot(x,exp(x))

exp([1j*np.pi])

x = np.linspace(0,2*np.pi,100)

f = 10/(2*np.pi)
W = 1

y = W*exp(-2*np.pi*f*x*1j)

plt.plot(x,y)

x = np.linspace(0,1,100)

f = 5
W = 1

y = W*exp(-2*np.pi*f*x*1j-0.5*1j*np.pi)

plt.plot(x,y)

y = W*exp(-2*np.pi*f*x*1j)

plt.plot(x,y)

plt.plot((W*exp(-2*np.pi*f*x*1j)**2+W*exp(-2*np.pi*f*x*1j-0.5*1j*np.pi)**2)[0:round(max(x))+1]);

x = np.linspace(0,1,100)

f = 1
W = 1

y = W*exp(-2*np.pi*f*x)
plt.plot(x,y)

y2 = W*np.exp(-2*np.pi*f*x)
plt.plot(x,y2)

x = np.linspace(0,2*np.pi,1000)

f = 2*np.pi/(2*np.pi)
W = 1

y = np.transpose(W*exp(-2*np.pi*f*x*1J)-exp([np.pi*1j]))

plt.plot(x,y)

plt.plot(x,np.sin(2*np.pi*x))

"""### Orbital becoming thermal"""

x = np.linspace(-4*np.pi,4*np.pi,1000)

f = 1*np.pi/(2*np.pi)  # 0.1, 2 or 10*np.pi/(2*np.pi)
W = 1

y = np.transpose(W*exp2(-2*np.pi*f*x*1J)-exp2([np.pi*1j]))

plt.plot(x,y);

#plt.polar(x,np.sin(f*2*np.pi*x))

"""#### Coil of wire"""

x = np.linspace(-4*np.pi,4*np.pi,1000)

f = 0.99*np.pi/(2*np.pi)  # 0.1, 2 or 10*np.pi/(2*np.pi)
W = 1

y = np.transpose(W*exp(-2*np.pi*f*x*1J)-exp([np.pi*1j]))

plt.plot(x,y);

#plt.polar(x,np.sin(f*2*np.pi*x))

plt.polar(x,y);

"""## Waves"""

# W = 2
# f = 2
# x = np.linspace(0,2,10000)+1

# y = W*exp(2*np.pi*f*x*1J-0.5J*np.pi)

# plt.plot(x,y)


W = 3
f = 3
x = np.linspace(0,1000,10000)+2

y = W*exp(2*np.pi*f*x*1J-0.5J*np.pi)

plt.plot(x,y)


# W = 4
# f = 4
# x = np.linspace(0,1,1000)+3

# y = W*exp(2*np.pi*f*x*1J-0.5J*np.pi)

#plt.plot(x,y)

def primewave(n):

  W = n
  f = n
  x = np.linspace(0,1,1000)+n-1

  y = W*np.exp(2*np.pi*f*x*1J-0.5J*np.pi)

  plt.polar(x,y);

  return y

def primewave(n):

  W = n
  f = n
  x = np.linspace(0,1,1000)+n-1

  y = W*np.exp(2*np.pi*f*x*1J-0.5J*np.pi)

  plt.plot(x,y);

  return y

for i in range(0,10):
  y = primewave(i)

for i in range(0,20,2):
  y = primewave(i)

"""## Fibonacci sequence makes it look 3D"""

for i in [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377]:
  y = primewave(i)

"""## Primes"""

primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]

for i in primes[0:20]:
  y = primewave(i)

W = 2
f = 2
x = np.linspace(0,1,1000)

y = W*np.exp(2*np.pi*f*x*1J)

plt.plot(x,y)

def primewave(n):

  W = n
  f = n
  x = np.linspace(0,1,1000)+n-1

  y = W*np.exp(2*np.pi*f*x*1J-0.5J*np.pi)

  plt.plot(x+0.5,y);
  plt.plot(-y,x+0.5);

  plt.plot(x+0.5,y);
  plt.plot(-y,x+0.5);

  return y

fib = 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377

for i in fib[0:5]:
  y = primewave(i)

for i in fib[0:5]:
  y = primewave(-i)

"""# 2D solar system"""

